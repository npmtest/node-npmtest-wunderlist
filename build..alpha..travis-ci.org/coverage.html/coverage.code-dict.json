{"/home/travis/build/npmtest/node-npmtest-wunderlist/test.js":"/* istanbul instrument in package npmtest_wunderlist */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wunderlist/lib.npmtest_wunderlist.js":"/* istanbul instrument in package npmtest_wunderlist */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wunderlist = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wunderlist = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wunderlist/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wunderlist && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wunderlist */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wunderlist\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wunderlist.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wunderlist.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wunderlist.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wunderlist.__dirname + '/lib.npmtest_wunderlist.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/wunderlist/Wunderlist.js":"'use strict';\n\n/**\n  * @module wunderlist/Wunderlist\n\n  * @requires module:wunderbits.core/WBEventEmitter\n  * @requires module:wunderbits/lib/dependencies\n\n  * @requires module:services/Folders\n  * @requires module:services/Lists\n  * @requires module:services/Memberships\n  * @requires module:services/Notes\n  * @requires module:services/Reminders\n  * @requires module:services/Settings\n  * @requires module:services/Subtasks\n  * @requires module:services/Tasks\n  * @requires module:services/UserEvents\n  * @requires module:services/Activities\n  * @requires module:services/Conversations\n  * @requires module:services/UnreadCounts\n\n  * @requires module:io/RestSocket\n  *\n  * @extends module:wunderbits.core/WBEventEmitter\n\n  * @example <caption>Create an instance of the main Wunderlist class</caption>\n    var WunderlistSDK = require('wunderlist/Wunderlist');\n\n    // Returns an instance of the Wunderlist SDK setup with the correct client ID and user access token\n    // and sets up a single WebSocket connection for REST over socket proxying\n    var wunderlistSDK = new WunderlistSDK({\n      'accessToken': 'a user token',\n      'clientID': 'your application id'\n    });\n\n    wunderlistSDK.initialized.done(function () {\n      // Where handleListData and handleError are functions\n      // 'http' here can be replaced with 'socket' to use a WebSocket connection for all requests\n      wunderlistSDK.http.lists.all()\n        // handleListData will be called with the object parsed from the response JSON\n        .done(handleListData)\n        // handleError will be called with the error/event\n        .fail(handleError);\n    });\n\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\nvar extend = core.lib.extend;\n\nvar AjaxTransport = require('../io/io/AjaxTransport');\nvar config = require('../config/default');\nvar ApplicationStateModel = require('../models/ApplicationState');\nvar IOHttp = require('../io/IO');\nvar RestSocket = require('../io/RestSocket');\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\nvar ServiceClasses = require('../services');\n\nvar MagiConsole = require('magiconsole');\n\nvar _super = WBEventEmitter.prototype;\n\nvar Wunderlist = WBEventEmitter.extend({\n\n  /**\n    * @todo revisit in the future and remove,\n    * auth will probably only be available through OAuth.\n    */\n  'auth': undefined,\n\n  /**\n    * Deferred object for tracking initialization success or failure.\n    * @type {deferred}\n    */\n  'state': undefined,\n\n  /**\n    * Flag to denote network connectivity.\n    * Note: this flag is only to denote a network connection, not API status.\n    */\n  'online': undefined,\n\n  /**\n    * State promise for attaching to initialization events.  Promise of state.\n    * @type {promise}\n    */\n  'initialized': undefined,\n\n  /**\n    * Holds references to instances of API HTTP service modules once Wunderlist initialization is completed and successful.\n    * @type {object}\n    * @property {instance} [folders] - HTTP Instance of {@link module:services/Folders}\n    * @property {instance} [lists] - HTTP Instance of {@link module:services/Lists}\n    * @property {instance} [memberships] - HTTP Instance of {@link module:services/Memberships}\n    * @property {instance} [notes]- HTTP Instance of {@link module:services/Notes}\n    * @property {instance} [reminders] - HTTP Instance of {@link module:services/Reminders}\n    * @property {instance} [settings] - HTTP Instance of {@link module:services/Settings}\n    * @property {instance} [subtasks] - HTTP Instance of {@link module:services/Subtasks}\n    * @property {instance} [tasks] - HTTP Instance of {@link module:services/Tasks}\n    * @property {instance} [userEvents] - HTTP Instance of {@link module:services/UserEvents}\n    */\n  'http': undefined,\n\n  /**\n    * Holds references to instances of API WebSocket service modules once Wunderlist initialization is completed and successful.\n    * @type {object}\n    * @property {instance} [folders] - HTTP Instance of {@link module:services/Folders}\n    * @property {instance} [lists] - WebSocket Instance of {@link module:services/Lists}\n    * @property {instance} [memberships] - WebSocket Instance of {@link module:services/Memberships}\n    * @property {instance} [notes]- WebSocket Instance of {@link module:services/Notes}\n    * @property {instance} [reminders] - WebSocket Instance of {@link module:services/Reminders}\n    * @property {instance} [settings] - WebSocket Instance of {@link module:services/Settings}\n    * @property {instance} [subtasks] - WebSocket Instance of {@link module:services/Subtasks}\n    * @property {instance} [tasks] - WebSocket Instance of {@link module:services/Tasks}\n    * @property {instance} [userEvents] - WebSocket Instance of {@link module:services/UserEvents}\n    */\n  'socket': undefined,\n\n  /**\n    * Main interface to Wunderlist API service modules.\n    * @constructor\n    * @param {object} options - Class initialization options.\n    * @param {string} options.clientID - Client ID is required.\n    * @param {string} options.accessToken - Wunderlist access token.\n    * @param {array} [options.services] - Services to be initialize.\n    *     If not present, all service modules will be initialized.\n    *     ex: 'services': ['lists', 'tasks']\n    * @param {boolean} [options.debug] - Enable logging\n    * @alias module:wunderlist/Wunderlist\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.options = options = extend(config, options || {});\n\n    self.setupLogging(self.options);\n\n    self.validateOptions();\n\n    self.appState = new ApplicationStateModel(options);\n\n    // initialise PlatformHeader\n    PlatformHeaders.init(options);\n\n    var state = self.state = new WBDeferred();\n    self.initialized = self.state.promise();\n\n    self.online = self.appState.isOnline();\n\n    self.start()\n      .done(state.resolveWith, state, self)\n      .fail(state.reject, state);\n  },\n\n  'setupLogging': function (options) {\n\n    options.logLevel && MagiConsole.setLevel(options.logLevel);\n    options.logPattern && MagiConsole.setPattern(options.logPattern);\n  },\n\n  /**\n    * Returns true once self.initialized is resolved.\n    * @type {boolean}\n    */\n  'isInitialized': function () {\n\n    var self = this;\n    return !!(self.initialized && self.initialized.state() === 'resolved');\n  },\n\n  /**\n    * Calls services initialization if/once authorized\n    * @returns {promise}\n    */\n  'start': function () {\n\n    var self = this;\n    var promise;\n\n    promise = self.getServices();\n\n    // watch online state\n    self.bindTo(self.appState, 'change:online', 'onOnlineOffline');\n\n    // report timings\n    self.bindTo(AjaxTransport, 'timing:io', 'onIOTiming');\n\n    return promise;\n  },\n\n  /**\n    * Set self.online state and trigger exposed online/offline event\n    */\n  'onOnlineOffline': function () {\n\n    var self = this;\n    self.online = self.appState.isOnline();\n    self.trigger(self.online ? 'online' : 'offline');\n  },\n\n  'onIOTiming': function (ioTimingData) {\n\n    var self = this;\n    self.trigger('timing:io', ioTimingData);\n  },\n\n  /**\n    * Creates instances of service modules according to initialization options.\n    * @param {array} [services] - Array of services to initialize.\n    * Default is initialize all services.\n    * @returns {promise} Hash of initialized services.\n    */\n  'getServices': function () {\n\n    var self = this;\n\n    var compiledServices = {\n      'http': {},\n      'socket': {}\n    };\n    var service, services, Klass;\n    var deferred = new WBDeferred();\n\n    var accessToken = self.appState.attributes.accessToken;\n\n    self.createSocket(accessToken).done(function createServices () {\n\n      // clear old services\n      self.http = undefined;\n      self.socket = undefined;\n\n      // from args, options, or default to all\n      services = services || self.options.services || Object.keys(ServiceClasses);\n\n      self.httpIO = new IOHttp({\n        'config': self.appState.toJSON()\n      });\n\n      for (var i = 0, len = services.length; i < len; i++) {\n        service = services[i];\n        Klass = ServiceClasses[service];\n\n        // http service\n        compiledServices.http[service] = new Klass({\n          'appState': self.appState,\n          'httpIO': self.httpIO\n        });\n        self.bindTo(compiledServices.http[service], 'unauthorized', self.onUnauthorized);\n\n        // socket service\n        compiledServices.socket[service] = new Klass({\n          'websocket': true,\n          'restSocket': self.restSocket,\n          'appState': self.appState\n        });\n      }\n\n      self.http = compiledServices.http;\n      self.socket = compiledServices.socket;\n\n      deferred.resolve(compiledServices);\n    });\n\n    return deferred.promise();\n  },\n\n  'isSocketOnline': function () {\n\n    var self = this;\n\n    var restSocket = self.restSocket;\n    var socket = restSocket && restSocket.socket;\n    var webSocketConnected = !!(socket && socket.isConnected());\n\n    return webSocketConnected;\n  },\n\n  /**\n    * Returns self.socket or self.http depending on self.restSocket.socket.connected\n    */\n  'getOutlet': function () {\n\n    var self = this;\n\n    var webSocketConnected = self.isSocketOnline();\n    var forcedHttp = !!self.options.forceHTTP;\n\n    return (webSocketConnected && !forcedHttp) ? self.socket : self.http;\n  },\n\n  /**\n    * Creates an instance of RestSocket using the current appState configuration\n    * @fires module:wunderlist/Wunderlist#event\n    * @returns {promise} Promise of WebSocket ready deferred\n    */\n  'createSocket': function () {\n\n    var self = this;\n\n    self.restSocket && self.unbindFrom(self.restSocket);\n\n    var restSocket = new RestSocket({\n      'appState': self.appState,\n      'config': self.options\n    });\n    self.restSocket = restSocket;\n\n    self.bindTo(restSocket, 'event', function (data) {\n\n      /**\n        * Realtime events messages event.\n        * @event module:wunderlist/Wunderlist#event\n        * @type {object}\n        */\n      self.trigger('event', data);\n    });\n\n    self.bindTo(restSocket, 'desktopNotification', function (data) {\n\n      /**\n        * Realtime desktop notifications.\n        * @event module:wunderlist/Wunderlist#desktopNotification\n        * @type {object}\n        */\n      self.trigger('desktopNotification', data);\n    });\n\n    self.bindTo(restSocket, 'unauthorized', self.onUnauthorized);\n    self.bindTo(restSocket, 'timing:io', 'onIOTiming');\n\n    return restSocket.ready.promise();\n  },\n\n  /**\n    * Destroys instance of Wunderlist on unauthorized event.\n    */\n  'onUnauthorized': function () {\n\n    var self = this;\n    self.trigger('unauthorized');\n    self.destroy();\n  },\n\n  /**\n    * Method to destroy and clean up instance.\n    */\n  'destroy': function () {\n\n    var self = this;\n\n    // kill the socket\n    self.restSocket && self.restSocket.destroy();\n\n    // clear all the bindings\n    self.unbindAll();\n\n    // destroy all the services\n    var protocols = ['http', 'socket'];\n    protocols.forEach(function (protocol) {\n\n      var theService;\n      for (var service in self[protocol]) {\n        theService = self[protocol][service];\n        theService.destroy && theService.destroy();\n      }\n      self[protocol] = undefined;\n    });\n\n    self.appState.destroy();\n\n    // delete all properties\n    // make sure a destroyed object is not keeping other\n    // objects alive by reference\n    function killEverything (obj) {\n      for (var key in obj) {\n        obj[key] = undefined;\n      }\n    }\n    killEverything(self);\n\n    // flag as destroyed, so objects internal methods\n    // can optionally check this before execution\n    self.destroyed = true;\n  },\n\n  /** TRUE when instance has been destroyed */\n  'destroyed': false,\n\n  /**\n    * Validates initialization options\n    * @returns {boolean} True if options are valid\n    */\n  'validateOptions': function () {\n\n    var self = this;\n    var options = self.options || {};\n\n    var validAuthCredentials = !!options.accessToken;\n    if (!options.clientID || !validAuthCredentials) {\n      throw new Error('Cannot initialize the Wunderlist SDK without a Client ID or auth credentials');\n    }\n  },\n\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n\n    var restSocket = self.restSocket;\n    var httpIO = self.httpIO;\n    restSocket && restSocket.cancelInflightCreate(requestID, onlineID, revision);\n    httpIO && httpIO.cancelInflightCreate(requestID, onlineID, revision);\n  }\n}, {\n  'services': ServiceClasses,\n  'headers': PlatformHeaders\n});\n\nmodule.exports = Wunderlist;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/io/AjaxTransport.js":"'use strict';\n\n/**\n  * Ajax transport that permits a maximum number of open http connections.\n  * Queueing and flushing is handled automagically.\n  * @module io/io/AjaxTransport\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBDeferred\n  * @requires module:wunderbits.core/lib/createUID\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/lib/SafeParse\n  * @requires module:io/io/NativeXMLHttpRequest\n  *\n  * @example\n  * var ajax = require('io/io/AjaxTransport').ajax;\n  * var request = ajax('http://www.example.comt/api/endpoint', {\n  *   'type': 'GET',\n  *   'data': {\n  *     'param': 'value'\n  *   },\n  *   'success': function (data, xhr) {//...},\n  *   'error': function (data, xhr) {//...}\n  * });\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar urlHelper = require('../../helpers/URL');\nvar SafeParse = require('../../wunderbits/lib/SafeParse');\nvar XHR = require('./NativeXMLHttpRequest');\nvar RequestDeferred = require('../../deferreds/RequestDeferred');\nvar RequestQueueMixin = require('../mixins/RequestQueueMixin');\n\nvar AjaxRequestQueueMixin = RequestQueueMixin.extend({\n\n  'maxRequests': 5,\n\n  /**\n  * Executes a pending request\n  * @param {object} requestData - queued request data\n  */\n  'executeRequest': function (requestData) {\n\n    var self = this;\n\n    var url = requestData.url;\n    var options = requestData.options;\n    var deferred = requestData.deferred;\n\n    self.executingRequests[requestData.queueID] = requestData;\n\n    var request = self.xhrRequest(url, {\n\n      'type': options.type,\n      'data': options.data,\n      'headers': options.headers,\n      'timeout': options.timeout\n    }, deferred);\n\n    request\n      .done(function (data, xhr) {\n\n        self.onSuccess(data, xhr, options);\n      })\n      .fail(function (data, xhr) {\n\n        self.onFailure(data, xhr, options);\n      })\n      .always(function () {\n\n        delete self.executingRequests[requestData.queueID];\n        self.checkQueue();\n      });\n  }\n});\n\nvar AjaxTransport = WBSingleton.extend({\n\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin,\n    AjaxRequestQueueMixin\n  ],\n\n  /**\n    * Creates and sends an XMLHttpRequest\n    * @param {string} url - url for the request\n    * @param {object} options - request options\n    * @param {string} options.type - request type/method, GET, POST, PUT, DELETE\n    * @param {object} [options.data] - request data.  Automatically converted to url params for GET requests\n    * @param {number} [options.timeout] - request timeout duration\n    * @param {object} [options.headers] - request headers\n    * @param {deferred} requestDeferred - request deferred object\n    */\n  'xhrRequest': function (url, options, requestDeferred) {\n\n    var self = this;\n\n    var async = true;\n    var method = options.type;\n    var data = options.data;\n\n    // // move data to URL as params\n    if (data && method === 'GET') {\n      url = urlHelper.generateURI(url, data);\n      // unset data so it is not used further down\n      data = undefined;\n    }\n\n    // Open request\n    var request = new XHR();\n\n    // set handlers (BEFORE #OPEN)\n    self.attachXhrListeners(request, requestDeferred);\n\n    request.open(method, url, async);\n\n    // setup timeout (AFTER #OPEN)\n    if (options.timeout) {\n      request.timeout = options.timeout;\n    }\n\n    // set headers (BEFORE #SEND)\n    self.setupXhrHeaders(request, options.headers, data);\n\n    requestDeferred.startTime = Date.now();\n\n    data ? request.send(data) : request.send();\n\n    // expose some useful things on the deferred request object:\n    requestDeferred.url = url;\n    requestDeferred.xhr = request;\n\n    return requestDeferred;\n  },\n\n  /**\n    * Sets up appropriate headers for an XMLHttpRequest\n    * @param {XMLHttpRequest} request - XMLHttpRequest\n    * @param {object} [headers] - custom headers\n    * @param {object} [data] - request data, if present content-type application/json header will be set\n    */\n  'setupXhrHeaders': function (request, headers, data) {\n\n    var weSpeakJSON = 'application/json; charset=utf-8';\n\n    // set request headers\n    if (headers) {\n      for (var header in headers) {\n        request.setRequestHeader(header.toLowerCase(), headers[header]);\n      }\n    }\n\n    // Set the correct headers for content-type and accept\n    // Note: these are case sensitive for the node XHR object, do not to lower them!\n    if (data) {\n      request.setRequestHeader('Content-Type', weSpeakJSON);\n    }\n    // Set accept header\n    request.setRequestHeader('Accept', weSpeakJSON);\n  },\n\n  /**\n    * Attaches event listeners to an XMLHttpRequest\n    * @param {XMLHttpRequest} request - XMLHttpRequest\n    * @param {requestDeferred} requestDeferred - request deferred\n    */\n  'attachXhrListeners': function (request, requestDeferred) {\n\n    var self = this;\n\n    // handlers\n    request.addEventListener('progress', function (ev) {\n\n      self.onXhrProgress(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('load', function (ev) {\n\n      self.onXhrLoad(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('error', function (ev) {\n\n      self.onXhrError(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('abort', function (ev) {\n\n      self.onXhrAbort(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('timeout', function (ev) {\n\n      self.onXhrTimeout(ev, request, requestDeferred);\n    }, false);\n  },\n\n  /**\n    * Handles rejecting or reolving request deferred\n    * @param {event} ev - raw event object from XMLHttpRequest\n    * @param {XMLHttpRequest} request - the originating XMLHttpRequest\n    * @param {requestDeferred} requestDeferred - the request deferred object\n    */\n  'onXhrLoad': function (ev, request, requestDeferred) {\n\n    var self = this;\n\n    var isSuccess = parseInt(request.status / 100, 10) === 2;\n    if (isSuccess) {\n      self.triggerTiming(requestDeferred);\n    }\n\n    requestDeferred[isSuccess ? 'resolve' : 'reject'].call(requestDeferred, request.responseText, request);\n  },\n\n  'triggerTiming': function (requestDeferred) {\n\n    var self = this;\n\n    var now = Date.now();\n    var requestTime = requestDeferred.startTime;\n    var loadStart = requestDeferred.loadStartTime;\n    requestDeferred.loadDurationTime = now - loadStart;\n    requestDeferred.latencyTime = loadStart - requestTime;\n\n    self.trigger('timing:io', {\n      'start': requestTime,\n      'end': now,\n      'duration': now - requestTime,\n      'latency': requestDeferred.latencyTime,\n      'download': requestDeferred.loadDurationTime,\n      'url': requestDeferred.url,\n      'type': 'ajax'\n    });\n  },\n\n  'onXhrProgress': function (ev, request, requestDeferred) {\n\n    if (!requestDeferred.loadStarted) {\n      requestDeferred.loadStartTime = Date.now();\n      requestDeferred.loadStarted = true;\n    }\n  },\n\n  /** Handles XMLHttpRequest error events */\n  'onXhrError': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrError', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest abort events */\n  'onXhrAbort': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrAbort', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest timeout events */\n  'onXhrTimeout': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrTimeout', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest failure events */\n  'onXhrFail': function (ev, request, requestDeferred) {\n\n    requestDeferred.reject(request.responseText, request);\n  },\n\n  /**\n    * Main transport request method\n    * @param {string} url - request url\n    * @param {object} options - request options\n    * @returns {deferred}\n    */\n  'ajax': function (url, options) {\n\n    var self = this;\n    var request = self.queueRequest(url, options, RequestDeferred);\n    return request;\n  },\n\n  /** Handles successful ajax request responses */\n  'onSuccess': function (data, xhr, options) {\n\n    if (typeof data === 'string' && xhr.status !== 204) {\n      data = SafeParse.json(data);\n    }\n\n    options.success && options.success(data, xhr);\n  },\n\n  /** Handles unsuccessful ajax request responses */\n  'onFailure': function (data, xhr, options) {\n\n    // this does not work with cross-domain firefox,\n    // it will always return an empty string\n    // yay mozilla!!\n    var contentType = (xhr.getResponseHeader('content-type') || '').split(';')[0];\n    if (typeof data === 'string' && (/application\\/json/.test(contentType))) {\n      data = SafeParse.json(xhr.responseText);\n    }\n\n    if (typeof options.error === 'function') {\n      options.error(data, xhr);\n    }\n  }\n});\n\nmodule.exports = AjaxTransport;","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/helpers/URL.js":"'use strict';\n\n/**\n* @module helpers/URL\n* @requires module:wunderbits.core/WBSingleton\n*/\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar URLHelper = WBSingleton.extend({\n\n  /**\n    * Compiles hash of request parameters into a valid URI component\n    * @param {object} params - Hash of request parameters\n    */\n  'compileParams': function (params) {\n\n    var first = true;\n    var component = '';\n    var value;\n\n    for (var key in params) {\n      value = encodeURIComponent(params[key]);\n      component += (first ? '?' : '&') + key + '=' + encodeURIComponent(value);\n\n      if (first) {\n        first = false;\n      }\n    }\n\n    return component;\n  },\n\n  /**\n    * Helper for generating full URI from a host (with path) and a params hash.\n    * @param {string} host - Host and path part of URI\n    * @param {object} params - Hash of URI params and values.\n    */\n  'generateURI': function (host, params) {\n\n    var self = this;\n\n    return host + self.compileParams(params);\n  }\n});\n\nmodule.exports = URLHelper;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/wunderbits/lib/SafeParse.js":"'use strict';\n\n/**\n  * Parse different data types to things\n  * @module wunderbits/lib/SafeParse\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits/lib/console\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SAFEPARSE');\n\nvar SafeParse = WBSingleton.extend({\n\n  /**\n    * Apptempts to parse a json sring to an object without throwing\n    * unhandled errors.  Returns undefined if unable to parse json string.\n    */\n  'json': function (jsonString) {\n\n    try {\n      return JSON.parse(jsonString);\n    } catch (e) {\n      localConsole.warn('Unable to parse \"' + jsonString + '\"');\n    }\n    return;\n  }\n});\n\nmodule.exports = SafeParse;","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/io/NativeXMLHttpRequest.js":"'use strict';\n\n/**\n  * Returns browser XMLHttpRequest reference, or node.js xmlhttprequest reference\n  * @module io/io/NativeXMLHttpRequest\n  */\n\nmodule.exports = global.XMLHttpRequest || require('xmlhttprequest').XMLHttpRequest;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/deferreds/RequestDeferred.js":"'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar _super = WBDeferred.prototype;\n\nvar RequestDeferred = WBDeferred.extend({\n\n  'properties': {\n\n    'loadDurationTime': undefined,\n    'loadStarted': false,\n    'loadStartTime': undefined,\n    'latencyTime': undefined,\n\n    'startTime': undefined,\n    'url': undefined,\n    'xhr': undefined,\n  },\n\n  'error': _super.fail\n});\n\nmodule.exports = RequestDeferred;","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/mixins/RequestQueueMixin.js":"'use strict';\n\n/**\n  * Request queue mixin for throttling http and rest socket requests\n  * @module io/mixins/RequestQueueMixin\n  * @extends wunderbits/WBMixin\n  * @requires validators/SchemaValidator\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar WBMixin = core.WBMixin;\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Maximum number of open ajax requests.\n    * @type {number}\n    */\n  'maxRequests': 5,\n\n  /**\n    * Queue of pending ajax requests\n    * @type {array}\n    */\n  'requestsQueue': [],\n\n  /**\n    * Hash of currently executing ajax requests\n    * @type {object}\n    */\n  'executingRequests': {},\n\n  /** Resets queues*/\n  'reset': function () {\n\n    var self = this;\n    self.requestsQueue = [];\n    self.executingRequests = {};\n  },\n\n  /** Checks request queue for pending requests and flushes if allowed*/\n  'checkQueue': function () {\n\n    var self = this;\n    var requests = Object.keys(self.executingRequests).length;\n    var requestData;\n\n    if (requests < self.maxRequests) {\n      requestData = self.requestsQueue.shift();\n      requestData && self.executeRequest(requestData);\n    }\n  },\n\n  /**\n    * Queues a request and creates request's deffered object.\n    * @param {string} url - request URL\n    * @param {object} options - request options\n    * @param {constructor} RequestDeferredClass - request deferred contructor\n    * @returns {deferred}\n    */\n  'queueRequest': function (url, options, RequestDeferredClass) {\n\n    var self = this;\n    var deferred = new RequestDeferredClass();\n\n    self.requestsQueue.push({\n\n      'deferred': deferred,\n      'url': url,\n      'options': options,\n      'queueID': createUID()\n    });\n\n    self.checkQueue();\n\n    return deferred;\n  },\n\n  'executeRequest': function (requestData) {\n\n    throw new Error('You must override RequestQueueMixin#executeRequest!', requestData);\n\n    // // Example from AjaxTransport#executeRequest\n    // var self = this;\n\n    // var url = requestData.url;\n    // var options = requestData.options;\n    // var deferred = requestData.deferred;\n\n    // self.executingRequests[requestData.queueID] = requestData;\n\n    // var request = self.xhrRequest(url, {\n\n    //   'type': options.type,\n    //   'data': options.data,\n    //   'headers': options.headers,\n    //   'timeout': options.timeout\n    // }, deferred);\n\n    // request\n    //   .done(function (data, xhr) {\n\n    //     self.onSuccess(data, xhr, options);\n    //   })\n    //   .fail(function (data, xhr) {\n\n    //     self.onFailure(data, xhr, options);\n    //   })\n    //   .always(function () {\n\n    //     delete self.executingRequests[requestData.queueID];\n    //     self.checkQueue();\n    //   });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/config/default.js":"'use strict';\n\n/**\n  * Default configuration file.\n  * Overidable in SDK constructor.\n  * @module config/default\n  */\n\nmodule.exports = {\n  /**\n    * Wunderlist SDK Version\n    * @type {string}\n    */\n  'release': '0.0.0',\n\n  /**\n    * Your Client Identification Number/String\n    * @type {string}\n    */\n  'clientID': undefined,\n\n  /**\n    * WebSocket connection timeout (in ms)\n    * @type {number}\n    */\n  'webSocketTimeout': 15 * 1000,\n\n  'api': {\n    'host': 'https://a.wunderlist.com/api',\n  },\n\n  'realtime': {\n    'host': 'wss://socket.wunderlist.com:8443/api/v1/sync'\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/models/ApplicationState.js":"'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\nvar WBStateModel = core.WBStateModel;\nvar clone = core.lib.clone;\nvar WBOnlineStatus = require('../wunderbits/WBOnlineStatus');\n\nvar _super = WBStateModel.prototype;\nvar ApplicationState = WBStateModel.extend({\n\n  'defaults': {\n    'api': {\n      'host': 'https://a.wunderlist.com/api',\n    },\n    'realtime': {\n      'host': 'wss://socket.wunderlist.com:8443/api/v1/sync'\n    },\n    'accessToken': undefined,\n    'clientID': undefined,\n    'debug': false,\n    'online': true,\n    'webSocketTimeout': 15 * 1000,\n    'maxHttpRequests': 5,\n    'checkHealth': true\n  },\n\n  'initialize': function () {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.initialized = new WBDeferred();\n\n    setTimeout(function () {\n\n      if (self.destroyed) {\n        return;\n      }\n\n      // Hack until wb.core is updated with correct initialize chains\n      self.watchOnlineState();\n      self.initialized.resolve();\n    });\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.onlineState && self.onlineState.destroy();\n    _super.destroy.apply(self, arguments);\n  },\n\n  'watchOnlineState': function () {\n\n    var self = this;\n\n    if (self.onlineState) {\n      self.unbindFrom(self.onlineState);\n      self.onlineState.destroy();\n    }\n\n    self.onlineState = new WBOnlineStatus({\n      'config': self.toJSON()\n    });\n\n    self.set('online', self.onlineState.isOnline());\n\n    self.bindTo(self.onlineState, 'online', 'onOnline');\n    self.bindTo(self.onlineState, 'offline', 'onOffline');\n  },\n\n  'onOnline': function () {\n\n    this.set('online', true);\n  },\n\n  'onOffline': function () {\n\n    this.set('online', false);\n  },\n\n  'isOnline': function () {\n\n    return !!this.attributes.online;\n  },\n\n  'toJSON': function () {\n\n    return clone(this.attributes);\n  }\n});\n\nmodule.exports = ApplicationState;","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/wunderbits/WBOnlineStatus.js":"'use strict';\n\n\n// Network connectivity monitor.\n// Based on http://robertnyman.com/html5/offline/online-offline-events.html\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\n\nvar HealthCheck = require('../helpers/HealthCheck');\n\nvar navigator = global.navigator || { 'onLine': true };\n\nvar WBOnlineStatus = WBEventEmitter.extend({\n\n  'online': null,\n\n  'initialize': function (options) {\n\n    var self = this;\n    var document = global.document;\n\n    self.online = navigator.onLine;\n\n    if (global.addEventListener) {\n      // normal browsers\n      global.addEventListener('online', self.onOnline.bind(self), false);\n      global.addEventListener('offline', self.onOffline.bind(self), false);\n    }\n    // ie ?\n    else if (document) {\n      var body = document.body;\n      body.ononline = self.isOnline;\n      body.onoffline = self.isOffline;\n    }\n\n    options.config.checkHealth && self.bindToApiHealth(options);\n  },\n\n  'destroy': function () {\n\n    HealthCheck.destroy();\n  },\n\n  'bindToApiHealth': function (options) {\n\n    var self = this;\n\n    HealthCheck.init(options);\n\n    self.bindTo(HealthCheck, 'healthy', 'onOnline');\n    self.bindTo(HealthCheck, 'unhealthy', 'onOffline');\n  },\n\n  'isOnline': function () {\n\n    return this.online;\n  },\n\n  'onOnline': function () {\n\n    var self = this;\n    self.online = true;\n    self.trigger('online');\n  },\n\n  'onOffline': function () {\n\n    var self = this;\n    self.online = false;\n    self.trigger('offline');\n  }\n});\n\nmodule.exports = WBOnlineStatus;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/helpers/HealthCheck.js":"'use strict';\n\n/**\n  * Aopi health checker\n  * @module helpers/HealthCheck\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar IOHttp = require('../io/IO');\n\nvar networkPollTime = 15 * 1000;\n\nvar HealthCheck = WBSingleton.extend({\n\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin\n  ],\n\n  'init': function (options) {\n\n    var self = this;\n\n    self.setupIO(options.config);\n    self.startPolling();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n    self.poller && clearInterval(self.poller);\n  },\n\n  'setupIO': function (config) {\n\n    var self = this;\n\n    if (!self.io) {\n      self.io = new IOHttp({\n        'config': config\n      }).io;\n    }\n  },\n\n  'startPolling': function () {\n\n    var self = this;\n\n    self.poller && clearInterval(self.poller);\n\n    self.poller = setInterval(function () {\n\n      self.checkApiHealth();\n    }, networkPollTime);\n  },\n\n  'checkApiHealth': function () {\n\n    var self = this;\n    self.io.get('/health')\n      .done(self.onHealthy, self)\n      .fail(self.onUnhealthy, self);\n  },\n\n  'onHealthy': function () {\n\n    var self = this;\n    self.trigger('healthy');\n  },\n\n  'onUnhealthy': function () {\n\n    var self = this;\n    self.trigger('unhealthy');\n  }\n});\n\nmodule.exports = HealthCheck;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/IO.js":"'use strict';\n\n/**\n  * Provides http IO.\n  * @module io/IO\n  * @extends module:io/IOBase\n  * @requires module:io/IOBase\n  *\n  * @example\n  * var IOHttp = require('io/IO');\n  *\n  * var params = {\n  *   'thingID': 1345\n  * };\n  *\n  * IOHttp.get('http://www.example.com/api/endpoint', params, 'asdflkj23094802938')\n  *   .done(function (response, code) {\n  *     //...\n  *   })\n  *   .fail(function (response, code) {\n  *     //...\n  *   });\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar WBDeferred = core.WBDeferred;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar SchemaValidator = require('../validators/SchemaValidator');\nvar IOBase = require('./IOBase');\n\nvar _super = IOBase.prototype;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:IO');\n\nvar IO = IOBase.extend({\n\n  // make our rest IO evented\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin\n  ],\n\n  /**\n    * @constructor\n    * @alias module:io/IO\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.config = options.config;\n\n    // set requests hash on instance\n    self.requests = {};\n\n    // verbs are programatically built by _super.initialize\n    // need to override now\n    self.wrapVerbs();\n  },\n\n  /**\n    * Moves unwrapped http verbs to _ prefixed names and sets up\n    * wrapped unprefixed verbs that execute through #requestWrapper\n    */\n  'wrapVerbs': function () {\n\n    var self = this;\n    var io = self.io;\n    ['get', 'patch', 'post', 'put', 'delete'].forEach(function (verb) {\n      io['_' + verb] = io[verb];\n      io[verb] = self.requestWrapper.bind(self, verb);\n    });\n  },\n\n  /**\n    * Hash for tracking requests made by an instance of this class\n    * @type {object}\n    */\n  'requests': {},\n\n  /**\n    * Map of token patterns for use by routes patterns\n    */\n  'tokens': {\n    'id': '([-])?[0-9]+',\n    'version': 'v(\\\\d)+',\n    'provider': '[a-z]+'\n  },\n\n  /**\n    * Map of paths patterns that should map to the 'api' host\n    */\n  'routes': {\n    'api': []\n  },\n\n  /**\n    * Map of paths patterns that do not require authorization headers\n    */\n  'authFreeRoutes': {\n    'api': [\n      'health',\n      '{{version}}/oauth/{{provider}}/exchange',\n      '{{version}}/signup',\n      '{{version}}/authenticate',\n      '{{version}}/user/password/reset'\n    ]\n  },\n\n  // make relative URLs absolute\n  'normalizeUrl': function (url) {\n\n    var self = this;\n    return self.config.api.host + url;\n  },\n\n  /**\n    * Extend #extendHeaders to inject clientID\n    */\n  'extendHeaders': function (headers) {\n\n    var self = this;\n\n    var clientID = self.config.clientID;\n    var deviceID = self.config.deviceID;\n    var instanceID = self.config.instanceID;\n\n    clientID && (headers['x-client-id'] = clientID);\n    deviceID &&(headers['x-client-device-id'] = deviceID);\n    instanceID && (headers['x-client-instance-id'] = instanceID);\n\n    if (typeof self.config.extendHeaders === 'function') {\n      self.config.extendHeaders(headers);\n    }\n\n    return _super.extendHeaders.apply(self, arguments);\n  },\n\n  /**\n    * Adds x-access-token and x-client-id headers to api endpoints that require them.\n    * @param {object} headers - current headers for the request being constructed\n    * @param {string} url - url for the request being constructed\n    */\n  'setAuthorization': function (headers) {\n\n    var self = this;\n\n    var accessToken = self.config.accessToken;\n    accessToken && (headers['x-access-token'] = accessToken);\n  },\n\n /**\n    * Wrapper for CRUD methods to inject supplied requestID, or auto generated requestID\n    * @returns {promise} Request promise.\n    * @param {string} method - HTTP method to execute\n    * @param {string} path - URI or path to make request against\n    * @param {object} [data] - Request body or hash of key value pairs for GET params\n    * @param {string} [requestID] - User supplied requestID to be sent as a header, auto generated if omitted\n    * @param {number} [timeout] - User supplied timeout in ms\n    */\n  'requestWrapper': function (method, path, data, requestID, timeout) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var headers = {};\n\n    if (!requestID) {\n      requestID = self.generateUID();\n    }\n\n    self.requests[requestID] = deferred;\n\n    headers['x-client-request-id'] = requestID;\n\n    timeout = timeout ? parseInt(timeout, 10) : 60000;\n\n    self.io['_' + method](path, data, headers, timeout)\n      .done(function (response, xhr) {\n\n        if (Array.isArray(response)) {\n          response.forEach(function (item) {\n\n            if (item.type) {\n              SchemaValidator.validateData(item, item.type);\n            }\n          });\n        }\n        else if (response && response.type) {\n          SchemaValidator.validateData(response, response.type);\n        }\n\n        localConsole.log(xhr.status, path);\n\n        // make the success state exatcly match socket success\n        deferred.resolve(response, xhr.status);\n      })\n      .fail(function (response, xhr) {\n\n        localConsole.error(xhr.status, xhr.statusText, path);\n\n        // make the failure state exactly match socket failure\n        deferred.reject(response, xhr.status);\n\n        if (xhr.status === 401) {\n          /**\n            * Unauthorized event\n            * @event module:io/IO#unauthorized\n            */\n          self.trigger('unauthorized');\n        }\n      })\n      .always(function () {\n        // drop reference, but keep id in hash\n        self.requests[requestID] = undefined;\n      });\n\n    return deferred.promise();\n  },\n\n  /**\n    * Generates unique indentifiers for proxy requests.\n    * @returns {string} UID\n    */\n  'generateUID': function () {\n\n    var self = this;\n    var uid;\n\n    while (!uid || !self.isUIDValid(uid)) {\n      uid = createUID();\n    }\n\n    return uid;\n  },\n\n  /**\n    * Checks that UID is not already used by a pending known request.\n    * @param {string} uid - UID\n    * @returns {boolean} - returns TRUE iff valid\n    */\n  'isUIDValid': function (uid) {\n\n    return !(uid in this.requests);\n  },\n\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n    var request = self.requests[requestID];\n\n    localConsole.debug('cancelling request locally', requestID, 'alive?', !!request);\n\n    if (request) {\n      self.requests[requestID] = undefined;\n      var data = onlineID ? {'id': onlineID} : {};\n      data.revision = revision;\n      request.resolve(data, 200);\n    }\n  }\n});\n\nmodule.exports = IO;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/validators/SchemaValidator.js":"'use strict';\n\n/**\n  * @module validators/SchemaValidator\n  * @extends wunderbits/WBSingleton\n  * @requires module:schema/List\n  * @requires module:schema/Subtask\n  * @requires module:schema/Task\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SCHEMAVALIDATOR');\n\nvar _schemas = require('../schemas');\n\nvar _validatorByType = {\n  'array': 'isArray',\n  'integer': 'isInteger',\n  'boolean': 'isBoolean',\n  'string': 'isString',\n  'ISODate': 'isISODate'\n};\n\nvar SchemaValidator = WBSingleton.extend({\n\n  /**\n    * Validates a data object based on a schema\n    * @param {object}\n    */\n  'validateData': function (data, type) {\n\n    var self = this;\n    var isAllDataIsValid = true;\n    var dataType, validtor, isValid, value;\n\n    var schema = _schemas[type];\n\n    if (!schema) {\n      localConsole.warn('No data schema for type \"' + type + '\"');\n      return true;\n    }\n\n    for (var key in data) {\n\n      isValid = undefined;\n      dataType = schema[key];\n\n      if (!dataType) {\n        localConsole.warn('No validation set for key', key, 'for', type);\n      }\n\n      value = data[key];\n      validtor = self[_validatorByType[dataType]];\n\n      if (validtor) {\n        isValid = validtor.call(self, value);\n        if (!isValid) {\n          localConsole.warn(type + ' value ' + value + ' (' + typeof value + ') for key \"' + key + '\"\" did not pass validation for type ' + dataType);\n          isAllDataIsValid = false;\n        }\n        else {\n          // localConsole.debug('Value ' + value + ' (' + typeof value + ') for key \"' + key + '\"\" passed validation for type ' + dataType);\n        }\n      }\n    }\n\n    return isAllDataIsValid;\n  },\n\n  /**\n    * Returns true if is an Array\n    * @param {object} variable - The thing to check for Arrayness\n    */\n  'isArray': function (variable) {\n\n    return Array.isArray(variable);\n  },\n\n  /**\n    * Returns true if is a Boolean\n    * @param {object} variable - The thing to check for Booleaness\n    */\n  'isBoolean': function (variable) {\n\n    return variable === false || variable === true;\n  },\n\n  /**\n    * Returns true if is an Integer\n    * @param {object} variable - The thing to check for Integerness\n    */\n  'isInteger': function (variable) {\n\n    // http://stackoverflow.com/questions/3885817/how-to-check-if-a-number-is-float-or-integer\n    return typeof variable === 'number' && parseFloat(variable) === parseInt(variable, 10) && !isNaN(variable);\n  },\n\n  /**\n    * Returns true if is a String\n    * @param {object} variable - The thing to check for Stringness\n    */\n  'isString': function (variable) {\n\n    return typeof variable === 'string';\n  },\n\n  /**\n    * Returns true if is an ISO Date string\n    * @param {object} variable - The thing to check for ISO Dateness\n    */\n  'isISODate': function (variable) {\n\n    var self = this;\n\n    // do not even regex if not a string\n    if (!self.isString(variable)) {\n      return false;\n    }\n\n    var ISODate = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-2])T(0[0-9]|1[0-9]|2[0-3])(:([0-5][0-9])){2}(\\.\\d{3})?Z$/;\n    return ISODate.test(variable);\n  }\n});\n\nmodule.exports = SchemaValidator;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/index.js":"'use strict';\n\nvar PositionSchema = require('./Position');\n\nmodule.exports = {\n  'list': require('./List'),\n  'folder': require('./Folder'),\n  'membership': require('./Membership'),\n  'note': require('./Note'),\n  'reminder': require('./Reminder'),\n  'setting': require('./Setting'),\n  'service': require('./Service'),\n  'subtask': require('./Subtask'),\n  'task': require('./Task'),\n  'task_comment': require('./TaskComment'),\n  'user': require('./User'),\n  'team': require('./Team'),\n  'organization': require('./Organization'),\n  'list_position': PositionSchema,\n  'subtask_position': PositionSchema,\n  'task_position': PositionSchema\n};","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Position.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'values': SchemaTypes.arr\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/SchemaTypes.js":"'use strict';\n\nmodule.exports = {\n  'id': 'integer',\n  'int': 'integer',\n  'bool': 'boolean',\n  'arr': 'array',\n  'str': 'string',\n  'ISODate': 'ISODate'\n};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/BaseSchema.js":"'use strict';\n\nvar core = require('wunderbits.core');\nvar clone = core.lib.clone;\nvar extend = core.lib.extend;\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'task_id': SchemaTypes.id,\n  'list_id': SchemaTypes.id,\n  'user_id': SchemaTypes.id,\n\n  'revision': SchemaTypes.int,\n  'type': SchemaTypes.str,\n\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n\n  'extend': function (obj) {\n    return extend(clone(this), obj);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/List.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'created_by_id': SchemaTypes.id,\n  'list_type': SchemaTypes.str,\n  'title': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Folder.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'title': SchemaTypes.str,\n  'list_ids': SchemaTypes.arr,\n  'user_id': SchemaTypes.id,\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n  'revision': SchemaTypes.int,\n  'type': SchemaTypes.str\n};","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Membership.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'sender_id': SchemaTypes.id,\n  'state': SchemaTypes.str,\n  'owner': SchemaTypes.bool,\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Note.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'content': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Reminder.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'date': SchemaTypes.ISODate\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Setting.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'key': SchemaTypes.str,\n  'value': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Service.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'user_id': SchemaTypes.id,\n  'provider_id': SchemaTypes.str,\n  'provider_type': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Subtask.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'completed': SchemaTypes.bool,\n  'completed_at': SchemaTypes.ISODate,\n  'completed_by_id': SchemaTypes.id,\n\n  'created_by_id': SchemaTypes.id,\n  'title': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Task.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'assignee_id': SchemaTypes.id,\n\n  'completed': SchemaTypes.bool,\n  'completed_at': SchemaTypes.ISODate,\n  'completed_by_id': SchemaTypes.id,\n\n  'created_by_id': SchemaTypes.id,\n\n  'due_date': SchemaTypes.ISODate,\n\n  'starred': SchemaTypes.bool,\n\n  'title': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/TaskComment.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'read': SchemaTypes.bool,\n  'text': SchemaTypes.str\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/User.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'name': SchemaTypes.str,\n  'email': SchemaTypes.str,\n  'pro': SchemaTypes.bool\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Team.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'name': SchemaTypes.str,\n  'organization_id': SchemaTypes.id,\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n  'revision': SchemaTypes.int,\n  'team_type': SchemaTypes.str,\n  'type': SchemaTypes.str\n};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/schemas/Organization.js":"'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id\n};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/IOBase.js":"'use strict';\n\n// GENERIC BASE IO CLASS\n// returns class\n\nvar core = require('wunderbits.core');\nvar WBClass = core.WBClass;\nvar WBDeferred = core.WBDeferred;\nvar assert = core.lib.assert;\nvar extend = core.lib.extend;\n\nvar AjaxTransport = require('./io/AjaxTransport');\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\n\nvar _super = WBClass.prototype;\n\nvar absoluteUrlRegexp = /^(https?:)?\\/\\//;\nvar wlURLRegexp = /^(https?:)?\\/\\/\\w+\\.wunderlist.com\\//;\n\nmodule.exports = WBClass.extend({\n\n  'initialize': function (options) {\n\n    var self = this;\n    self.config = options.config;\n\n    AjaxTransport.maxRequests = self.config.maxHttpRequests || 5;\n\n    _super.initialize.apply(self, arguments);\n\n    self.io = AjaxTransport.ajax.bind(AjaxTransport);\n\n    // create io verbs on class\n    var crudOps = ['delete', 'get', 'patch', 'post', 'put'];\n    for (var i=0, len=crudOps.length; i<len; i++) {\n      self.defineVerb(crudOps[i]);\n    }\n\n    // compile routes for faster lookup\n    self.routes = self.compileRoutes(self.routes, self.tokens);\n    self.authFreeRoutes = self.compileRoutes(self.authFreeRoutes, self.tokens);\n  },\n\n  'compileRoutes': function (routes, tokens) {\n\n    var self = this;\n\n    // no routes defined\n    if (!routes) {\n      return undefined;\n    }\n\n    function markTokens (rule) {\n      return rule.replace(/\\{\\{(\\w+)\\}\\}/g, function (match, token) {\n        return tokens[token];\n      });\n    }\n\n    var compiled = {};\n    for (var service in routes) {\n      var rules = routes[service];\n      rules = rules.map(markTokens);\n      var regexp = new RegExp('^/(' + rules.join('|') + ')(\\\\?|$)');\n      var host = self.config[service].host;\n      compiled[host] = regexp;\n    }\n\n    return compiled;\n  },\n\n  // Change relative URLs to point to the correct host\n  // extend is subclass\n  'resolveUrl': function (url) {\n\n    var self = this, resolved;\n\n    // Don't touch absolute urls\n    if (absoluteUrlRegexp.test(url)) {\n      return url;\n    }\n\n    // if a known route\n    if (self.routes) {\n      resolved = self.resolveRoute(url);\n    }\n\n    // just make the url relative to the current domain\n    if (!resolved) {\n      resolved = self.normalizeUrl(url);\n    }\n\n    return resolved;\n  },\n\n  // resolve known routes to absolute urls\n  'resolveRoute': function (route) {\n\n    var self = this;\n    for (var host in self.routes) {\n      var regexp = self.routes[host];\n      if (regexp.test(route)) {\n        return host + route;\n      }\n    }\n  },\n\n  // make relative URLs absolute\n  'normalizeUrl': function (url) {\n    var location = global.location;\n    return location.protocol + '//' + location.host + url;\n  },\n\n  // add/remove/augment headers\n  // extend in subclass\n  'extendHeaders': function (headers, url) {\n\n    var self = this;\n\n    var isAbsoluteURL = absoluteUrlRegexp.test(url);\n    var isWLUrl = !isAbsoluteURL || wlURLRegexp.test(url);\n\n    // url is used by api extendHeaders\n    headers = headers || {};\n\n    // Also add custom headers needed for client-identification\n    if (isWLUrl) {\n      extend(headers, PlatformHeaders.headers);\n    }\n\n    // skip auth headers for certain urls\n    if (self.authFreeRoutes) {\n      for (var host in self.authFreeRoutes) {\n        var regexp = self.authFreeRoutes[host];\n        if (regexp.test(url)) {\n          return headers;\n        }\n      }\n    }\n\n    // Add Auth token for relative urls that need auth\n    // Don't modify any existing auth headers\n    if (isWLUrl && !headers.Authorization) {\n      self.setAuthorization(headers, url);\n    }\n\n    return headers;\n  },\n\n  'setAuthorization': function () {\n    // base class, does nothing\n  },\n\n  // Create functions for http verbs\n  'defineVerb': function (type) {\n\n    var self = this;\n\n    self.io[type] = function (url, data, headers, timeout, context) {\n\n      assert(url, 'need a url for ajax calls');\n\n      headers = headers || {};\n      headers = self.extendHeaders(headers, url);\n\n      var deferred = new WBDeferred();\n      var promise = deferred.promise();\n\n      // resolve the url to an absolute url\n      url = self.resolveUrl(url);\n\n      // format the data\n      if (typeof data === 'object') {\n        // convert to query params for get requests\n        if (type === 'get') {\n          var params = [], key;\n          for (key in data) {\n            params.push(key + '=' + encodeURIComponent(data[key]));\n          }\n          params.length && (url = url + '?' + params.join('&'));\n          data = undefined;\n        }\n        // for other methods, Serialize the data as json\n        else {\n          data = JSON.stringify(data);\n        }\n      }\n\n      // send the request\n      self.io(url, {\n        'type': type.toUpperCase(),\n        'data': data,\n        'headers': headers,\n        'success': deferred.resolve.bind(deferred),\n        'error': deferred.reject.bind(deferred),\n        'timeout': timeout,\n        'context': context\n      });\n\n      return promise;\n    };\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/helpers/PlatformHeaders.js":"'use strict';\n\n/**\n  * Holds reference for all important analytics platform headers.\n  * @module helpers/PlatformHeaders\n  * @extends module:wunderbits.core/WBSingleton\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar navigator = global.navigator || {};\nvar nodejs = global.process || {};\nvar userAgent = navigator.userAgent || ('node ' + nodejs.version);\n\nvar PlatformHeaders = WBSingleton.extend({\n  /**\n    * Precompiled platform headers.\n    * @type {object}\n    */\n  'headers': {\n    'x-client-platform': 'web',\n    'x-client-product':  'wunderlist',\n    'x-client-product-version': null,\n    'x-client-system': userAgent,\n    'x-client-system-version': 'Standard',\n    'x-client-product-git-hash': null\n  },\n\n  'init': function (options) {\n\n    var self = this;\n\n    var config = options;\n    var headers = self.headers;\n\n    headers['x-client-product-version'] = config.release;\n\n    var gitHash = /\\[(.*)\\]/.exec(config.gitHash);\n    gitHash = gitHash && gitHash[1];\n    headers['x-client-product-git-hash'] = gitHash || 'dev';\n\n    if (config.testing) {\n      headers['x-client-testing'] = 'true';\n    }\n\n    if (config.product) {\n      headers['x-client-product'] = config.product;\n    }\n  }\n});\n\nmodule.exports = PlatformHeaders;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/RestSocket.js":"'use strict';\n\n/**\n  * @module io/RestSocket\n  * @requires module:io/io/WebSocket\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/lib/SafeParse\n  * @requires module:wunderbits.core/lib/createUID\n  * @extends module:wunderbites/WBEventEmitter\n  *\n  * @example\n  * var IORestSocket = require('io/RestSocket');\n  *\n  * var params = {\n  *   'thingID': 1345\n  * };\n  *\n  * IORestSocket.get('http://www.example.com/api/endpoint', params, 'asdflkj23094802938')\n  *   .done(function (response, code) {\n  *     //...\n  *   })\n  *   .fail(function (response, code) {\n  *     //...\n  *   });\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar extend = core.lib.extend;\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\n\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\nvar RequestQueueMixin = require('./mixins/RequestQueueMixin');\nvar RestSocketRequestDeferred = require('../deferreds/RestSocketRequestDeferred');\nvar SafeParse = require('../wunderbits/lib/SafeParse');\nvar SchemaValidator = require('../validators/SchemaValidator');\nvar URLHelper = require('../helpers/URL');\nvar WebSocket = require('./io/WebSocket');\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:RESTSOCKET');\n\nvar SocketRequestQueueMixin = RequestQueueMixin.extend({\n\n  'maxRequests': 100,\n\n  'executeRequest': function (requestData) {\n\n    var self = this;\n\n    var options = requestData.options;\n\n    self.socketRequest(\n      requestData.deferred,\n      options.method,\n      options.uri,\n      options.data,\n      options.requestID,\n      options.requestType\n    )\n    .always(function executeRequestDone () {\n\n      delete self.executingRequests[requestData.queueID];\n      self.checkQueue();\n    });\n  }\n});\n\nvar _super = WBEventEmitter.prototype;\nvar RestSocket = WBEventEmitter.extend({\n\n  'mixins': [\n    SocketRequestQueueMixin\n  ],\n\n  /** Default RestSocket timout duration in milliseconds (16 seconds) */\n  'timeout': 60 * 1000,\n\n  /** Holds referenece to instance of WebSocket. */\n  'socket': undefined,\n\n  /** Deferred object for getting RestSocket state */\n  'ready': undefined,\n\n  /**\n    * Hash for managing inprogress WebSocket proxied REST requests\n    * @type {object}\n    */\n  'requests': {},\n\n  /**\n    * Wunderlist API RestSocket Module.\n    * Performs restful CRUD operations against the Wunderlist API over a WebSocket Proxy\n    * @constructor\n    * @alias module:io/RestSocket\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.appState = options.appState;\n    self.config = options.config;\n\n    self.ready = new WBDeferred();\n\n    self.socket = new WebSocket(options);\n\n    // set requests hash on instance\n    self.requests = {};\n\n    // verbs are programatically built by _super.initialize\n    // need to override now\n    self.wrapVerbs();\n\n    self.pollForTimeouts();\n    self.bindToSocket();\n    self.ready.resolve();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.unbindAll();\n    self.socket && self.socket.destroy();\n    self.destroyed = true;\n  },\n\n  /**\n    * Wrap the IO verbs\n    */\n  'wrapVerbs': function () {\n\n    var self = this;\n\n    // TODO: merge this with io.js#wrapVerbs\n    // maybe move this into a mixin\n    var verbs = ['get', 'post', 'put', 'patch', 'delete'];\n    verbs.forEach(function (verb) {\n\n      var fn = self[verb];\n      self[verb] = function () {\n        return fn.apply(self, arguments);\n      };\n    });\n  },\n\n  /**\n    * Sets up interval timer to check for request timeouts.\n    */\n  'pollForTimeouts': function () {\n\n    var self = this;\n\n    self.timer && clearInterval(self.timer);\n    self.timer = setInterval(function () {\n\n      self.checkForRequestTimeouts();\n    }, 1000);\n  },\n\n  /**\n    * Close raw WebSocket connection if open.\n    */\n  'close': function () {\n\n    var self = this;\n    self.socket && self.socket.close();\n  },\n\n  /** Binds to WebSocket message events */\n  'bindToSocket': function () {\n\n    var self = this;\n    self.bindTo(self.socket, 'open', 'onSocketConnect');\n    self.bindTo(self.socket, 'message', 'onMessage');\n    self.bindTo(self.socket, 'close', 'onSocketFalure');\n    self.bindTo(self.socket, 'close', 'onSocketDisconnect');\n    self.bindTo(self.socket, 'error', 'onSocketFalure');\n  },\n\n  /**\n    * Real socket is open and ready.  Trigger a connected event.\n    */\n  'onSocketConnect': function (e) {\n\n    var self = this;\n\n    self.getSocketHealth()\n      .done(function () {\n\n        self.connected = true;\n        self.trigger('connected', e);\n        self.pollHealth();\n      })\n      .fail(self.close, self);\n  },\n\n  /**\n    * Starts polling for health\n    */\n  'pollHealth': function () {\n\n    var self = this;\n\n    self.cancelPollHealth();\n\n    self.poller = setInterval(function () {\n\n      if (self.connected) {\n        self.getSocketHealth()\n          .fail(self.close, self);\n      }\n      else {\n        self.cancelPollHealth();\n      }\n    }, 15000);\n  },\n\n  /**\n    * Cancels the poller timer\n    */\n  'cancelPollHealth': function () {\n\n    var self = this;\n    self.poller && clearInterval(self.poller);\n  },\n\n  /**\n    * Get the socket health state\n    * @returns {promise} - A promise that resolves or rejects depending on the health\n    */\n  'getSocketHealth': function () {\n\n    var self = this;\n\n    var request = self.request(undefined, undefined, undefined, undefined, 'health')\n      .done(function (resp, code) {\n\n        localConsole.info('websocket healthy', resp || '', code);\n      })\n      .fail(function (resp, code) {\n\n        localConsole.error('websocket not healthy', resp || '', code);\n      });\n\n    return request.promise();\n  },\n\n  /**\n    * Real socket is closed.  Trigger a disconnected event.\n    */\n  'onSocketDisconnect': function (e) {\n\n    var self = this;\n\n    self.cancelPollHealth();\n    self.connected = false;\n    self.trigger('disconnected', e);\n  },\n\n  /**\n    * Handles incomming messages from WebSocket\n    * @param {event} e - WebSocket event\n    */\n  'onMessage': function (e) {\n\n    var self = this;\n    var data = SafeParse.json(e.data);\n    if (data && data.headers) {\n      data.headers = self.normalizeHeaders(data.headers);\n    }\n\n    var requestID = self.extractRequestIDFromHeaders(data);\n    var request = requestID && self.requests[requestID];\n    self.parseDataBody(data);\n\n    switch (data.type) {\n    case 'request':\n      request && self.handleRequest(request, data, requestID);\n      break;\n    case 'health':\n      request && self.handleHealthRequest(request, data, requestID);\n      break;\n    case 'desktop_notification':\n      self.handleDesktopNotification(data);\n      break;\n    case 'mutation':\n      self.isCorrectMutationVersion(data) && self.handleMessage(data);\n      break;\n    default:\n      self.handleMessage(data);\n    }\n  },\n\n  /**\n    * Extracts the request id from the data\n    * @param {object} data - the request data\n    * @returns {integer} id - the request id\n    */\n  'extractRequestIDFromHeaders': function (data) {\n\n    return data && data.headers && data.headers['x-client-request-id'];\n  },\n\n  /**\n    * Convert body on data to a real object\n    * @param {object} data - the request data\n    */\n  'parseDataBody': function (data) {\n\n    data && data.body && (data.body = SafeParse.json(data.body));\n  },\n\n  /**\n    * Validates realtime mutations to the correct api version\n    * @param {object} mutationData - raw mutation data\n    * @returns {bool}\n    */\n  'isCorrectMutationVersion': function (mutationData) {\n\n    var isCorrectVersion = false;\n\n    var type = mutationData.subject.type;\n    var version = mutationData.version;\n\n    var versionTwoEndpoints = [\n      'file'\n    ];\n\n    var canBeVersionTwo = versionTwoEndpoints.indexOf(type) !== -1;\n    var isVersionTwo = version === 2;\n    var isVersionOne = version === 1;\n\n    if (canBeVersionTwo && (isVersionTwo || isVersionOne)) {\n      isCorrectVersion = true;\n    }\n    else if (isVersionOne) {\n      isCorrectVersion = true;\n    }\n\n    return isCorrectVersion;\n  },\n\n  /**\n    * Handles messages that correspond to requests made by this module.\n    * @param {deferred} request - The request's deferred object.\n    * @param {data} data - The WebSocket message JSON parsed body.\n    */\n  'handleRequest': function (request, data, requestID) {\n\n    var self = this;\n\n    request.endTime = Date.now();\n\n    var okay = /^2/.test(data.status);\n    self.logRequestTimings(okay, request, data);\n\n    if (Array.isArray(data.body)) {\n      data.body.forEach(function (item) {\n\n        if (item.type) {\n          SchemaValidator.validateData(item, item.type);\n        }\n      });\n    }\n    else if (data.body && data.body.type) {\n      SchemaValidator.validateData(data.body, data.body.type);\n    }\n\n    request[okay ? 'resolve' : 'reject'](data.body, data.status);\n    self.checkStillAuthorized(data.status);\n    self.requests[requestID] = undefined;\n  },\n\n  /**\n    * Handles health requests\n    */\n  'handleHealthRequest': function (request, data, requestID) {\n\n    var self = this;\n\n    request.endTime = Date.now();\n\n    var okay = data.body && data.body.healthy === true;\n    self.logRequestTimings(okay, request, data);\n    request[okay ? 'resolve' : 'reject'](data.body, data.status);\n    self.requests[requestID] = undefined;\n  },\n\n  /**\n    * Handles request times\n    */\n  'logRequestTimings': function (okay, request, data) {\n\n    var args = [data.status, request.uri, request.endTime - request.startTime];\n    if (okay) {\n      this.triggerTiming(request);\n      localConsole.info.apply(localConsole, args);\n    }\n    else {\n      localConsole.error.apply(localConsole, args);\n    }\n  },\n\n  /**\n    * Triggers out timings\n    */\n  'triggerTiming': function (requestDeferred) {\n\n    var self = this;\n\n    var requestTime = requestDeferred.startTime;\n    requestDeferred.loadDurationTime = requestDeferred.endTime - requestTime;\n    requestDeferred.latencyTime = requestDeferred.loadDurationTime;\n\n    var timingData = {\n      'start': requestTime,\n      'end': requestDeferred.endTime,\n      'duration': requestDeferred.loadDurationTime,\n      'latency': requestDeferred.latencyTime,\n      // can't find any data available on\n      // websocket messages to calculate download time\n      'download': undefined,\n      'url': requestDeferred.uri,\n      'type': 'websocket'\n    };\n\n    // trigger on self\n    self.trigger('timing:io', timingData);\n  },\n\n  /**\n    * Triggers unauthorized event if the response status is 401.\n    * @param {Number} statusCode - HTTP Status Code\n    * @fires module:io/RestSocket#unauthorized\n    * @todo instance of Wunderlist class should destroy and cleanup self when unauthorized\n    */\n  'checkStillAuthorized': function (statusCode) {\n\n    var unauthorized = 'unauthorized';\n    if (statusCode === 401) {\n      /**\n        * Unauthorized event\n        * @event module:io/RestSocket#unauthorized\n        */\n      this.trigger(unauthorized);\n    }\n  },\n\n  /**\n    * Handle arbitrary WebSocket messages.\n    * @fires module:io/RestSocket#event\n    * @fires module:io/RestSocket#someCRUDOperation\n    */\n  'handleMessage': function (data) {\n\n    var self = this;\n\n    localConsole.debug('arbitrary message', data);\n\n    var type = data && data.subject && data.subject.type;\n    type && SchemaValidator.validateData(data.data, type);\n\n    /**\n      * Socket raw changes endpoint event\n      * @event module:io/RestSocket#event\n      * @type {object}\n      */\n    self.trigger('event', data);\n\n    var operation = data && data.operation;\n    if (operation) {\n      /**\n        * Socket scoped changes endpoint event\n        * @event module:io/RestSocket#someCRUDOperation\n        * @type {object}\n        */\n      self.trigger(operation, data);\n    }\n  },\n\n  /**\n    * Handle desktop notifications.\n    * @fires module:io/RestSocket#desktopNotification\n    */\n  'handleDesktopNotification': function (data) {\n\n    var self = this;\n\n    /**\n      * Socket desktop notifications\n      * @event module:io/RestSocket#desktopNotification\n      * @type {object}\n      */\n    self.trigger('desktopNotification', data);\n  },\n\n  /**\n    * Sets up restful proxy request to the Wunderlist API over a WebSocket\n    * @param {string} method - The rest CRUD operation: POST, GET, PUT, DELETE\n    * @param {string} uri - The API path to proxy to: /api/v1/settings\n    * @param {object} data - Data to send with a POST or PUT.\n    * @param {string} [requestID] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'request': function (method, uri, data, requestID, requestType) {\n\n    var self = this;\n\n    var options = {\n      'method': method,\n      'uri': uri,\n      'data': data,\n      'requestID': requestID,\n      'requestType': requestType\n    };\n\n    var request = self.queueRequest(uri, options, RestSocketRequestDeferred);\n    return request.promise();\n  },\n\n  /**\n    * Sends out a socket request\n    */\n  'socketRequest': function (requestDeferred, method, uri, data, requestID, requestType) {\n\n    var self = this;\n\n    var socket = self.socket;\n\n    requestID = requestID || self.generateUID();\n\n    var headers = self.compileHeaders(requestID);\n\n    var json = {\n      'type': requestType || 'request',\n      'headers': self.normalizeHeaders(headers)\n    };\n\n    method && (json.verb = method);\n    uri && (json.uri = uri);\n\n    if ((method === 'POST' || method === 'PATCH' || method === 'PUT') && data) {\n      json.body = JSON.stringify(data);\n    }\n\n    // add additional request information to the request deferred object\n    requestDeferred.requestID = requestID;\n    requestDeferred.uri = uri;\n    requestDeferred.startTime = Date.now();\n\n    self.requests[requestID] = requestDeferred;\n\n    // only send messages if the socket is still connected\n    if (self.appState.isOnline() && self.socket.isConnected()) {\n      socket.send(JSON.stringify(json));\n    }\n    else {\n      requestDeferred.reject({\n        'errors': ['no websocket connection available']\n      }, 0);\n    }\n\n    return requestDeferred.promise();\n  },\n\n  /**\n    * Compiles headers\n    */\n  'compileHeaders': function (requestID) {\n\n    var self = this;\n    var headers = {\n      'x-client-request-id': requestID,\n      'x-client-id': self.appState.attributes.clientID,\n      'x-client-instance-id': self.appState.attributes.instanceID,\n      'x-client-device-id': self.appState.attributes.deviceID,\n      'content-type': 'application/json',\n      'accept': 'application/json'\n    };\n\n    headers = extend(headers, PlatformHeaders.headers);\n\n    if (self.config && (typeof self.config.extendHeaders === 'function')) {\n      self.config.extendHeaders(headers);\n    }\n\n    var val;\n    for (var header in headers) {\n      val = headers[header];\n      if (val === undefined || val === null) {\n        delete headers[header];\n      }\n    }\n\n    return headers;\n  },\n\n  /**\n    * Normalizes headers to all lowercase\n    */\n  'normalizeHeaders': function (headers) {\n\n    var normalize = {};\n\n    for (var key in headers) {\n      normalize[key.toLowerCase()] = headers[key];\n    }\n\n    return normalize;\n  },\n\n  /**\n    * Wrapper for CRUD methods that calls #request when WebSocket is ready.\n    * @returns {promise} Request promise.\n    */\n  'requestWrapper': function (method, path, data, requestId) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    path = '/api' + path;\n\n    self.ready.done(function () {\n\n      self.request(method, path, data, requestId)\n        .done(deferred.resolve.bind(deferred))\n        .fail(deferred.reject.bind(deferred));\n    });\n\n    return deferred.promise();\n  },\n\n  /**\n    * Cancel all request on a socket failure event (close, error)\n    */\n  'onSocketFalure': function () {\n\n    var self = this;\n    var request;\n    for (var requestID in self.requests) {\n      request = self.requests[requestID];\n      request && request.reject({\n        'errors': ['websocket connection lost']\n      }, 0);\n      self.requests[requestID] = undefined;\n    }\n  },\n\n  /**\n    * Check for request timeouts.\n    */\n  'checkForRequestTimeouts': function () {\n\n    var self = this;\n    var now = Date.now();\n\n    for (var requestID in self.requests) {\n      self.checkRequestIsTimedout(self.requests[requestID], now);\n    }\n  },\n\n  /**\n    * Check if a request is timedout.\n    * @param {defferred} requestDeferred - Request deffered object\n    * @param {number} now - The time in milliseconds\n    */\n  'checkRequestIsTimedout': function (requestDeferred, now) {\n\n    var self = this;\n    if (requestDeferred && now - requestDeferred.startTime >= self.timeout) {\n\n      localConsole.error('timeout', requestDeferred.uri, now - requestDeferred.startTime);\n\n      requestDeferred.reject({\n        'errors': ['request timedout locally due to no response in ' + self.timeout]\n      }, 408);\n      self.requests[requestDeferred.requestID] = undefined;\n    }\n  },\n\n  /**\n    * Makes a DELETE proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} [params] - Params to send as part of delete request.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'delete': function (uri, params, requestId) {\n\n    var url = uri + URLHelper.compileParams(params);\n    return this.requestWrapper('DELETE', url, undefined, requestId);\n  },\n\n  /**\n    * Makes a GET proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} params - Request parameters (key value hash)\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'get': function (uri, params, requestId) {\n\n    var url = uri + URLHelper.compileParams(params);\n    return this.requestWrapper('GET', url, undefined, requestId);\n  },\n\n  /**\n    * Makes a PATCH proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'patch': function (uri, data, requestId) {\n    return this.requestWrapper('PATCH', uri, data, requestId);\n  },\n\n  /**\n    * Makes a POST proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'post': function (uri, data, requestId) {\n    return this.requestWrapper('POST', uri, data, requestId);\n  },\n\n  /**\n    * Makes a PUT proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'put': function (uri, data, requestId) {\n\n    return this.requestWrapper('PUT', uri, data, requestId);\n  },\n\n  /**\n    * Generates unique indentifiers for proxy requests.\n    * @returns {string} UID\n    */\n  'generateUID': function () {\n\n    var self = this;\n    var uid;\n\n    while (!uid || !self.isUIDValid(uid)) {\n      uid = createUID();\n    }\n\n    return uid;\n  },\n\n  /**\n    * Checks that UID is not already used by a pending known request.\n    * @param {string} uid - UID\n    * @returns {boolean} - returns TRUE iff valid\n    */\n  'isUIDValid': function (uid) {\n    return !(uid in this.requests);\n  },\n\n  /**\n    * Cancels in-flight socket requests\n    */\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n    var request = self.requests[requestID];\n\n    localConsole.debug('cancelling request locally', requestID, 'alive?', !!request);\n\n    if (request) {\n      self.requests[requestID] = undefined;\n      var data = onlineID ? {'id': onlineID} : {};\n      data.revision = revision;\n      request.resolve(data, 200);\n    }\n  }\n});\n\nmodule.exports = RestSocket;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/deferreds/RestSocketRequestDeferred.js":"'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar RestSocketRequestDeferred = WBDeferred.extend({\n\n  'properties': {\n    'startTime': undefined,\n    'endTime': undefined,\n    'requestID': undefined,\n    'uri': undefined\n  }\n});\n\nmodule.exports = RestSocketRequestDeferred;","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/io/WebSocket.js":"'use strict';\n\n/**\n  * @module io/io/WebSocket\n  * @requires module:wunderbits.core/lib/assert\n  * @requires module:wunderbits.core/WBEventEmitter\n  * @requires module:helpers/URL\n  * @requires module:magiconsole\n  * @requires module:io/io/NativeWebSocket\n  * @requires module:wunderbits/lib/bindAll\n  * @extends module:wunderbits.core/WBEventEmitter\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar assert = core.lib.assert;\n\nvar URLHelper = require('../../helpers/URL');\nvar NativeWebSocket = require('./NativeWebSocket');\nvar bindAll = require('../../wunderbits/lib/bindAll');\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:WEBSOCKET');\n\nvar _super = WBEventEmitter.prototype;\n\nvar WebSocketClass = WBEventEmitter.extend({\n\n  /**\n    * Was the socket connection close done by the client?\n    */\n  'clientClosed': false,\n\n  'NativeWebSocketClass': NativeWebSocket,\n\n  /** Holds reference to instance of native WebSocket */\n  'socket': undefined,\n\n  /**\n    * Wunderlist API native WebSocket Module\n    * @constructor\n    * @alias module:io/io/WebSocket\n    */\n  'initialize': function (options) {\n\n    var self = this;\n\n    self.appState = options.appState;\n\n    _super.initialize.apply(self, arguments);\n\n    // TODO: remove this ugly piece of shit, we don't need more binds\n    var fns = ['onSocketClose', 'onSocketError', 'onSocketMessage', 'onSocketOpen'];\n    bindAll(self, fns);\n\n    self.validateToken();\n    self.connect();\n    self.bindToAppState();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.close();\n    self.unbindAll();\n    self.destroyed = true;\n  },\n\n  'bindToAppState': function () {\n\n    var self = this;\n\n    if (self.appState) {\n      self.unbindFrom(self.appState);\n      self.bindTo(self.appState, 'change:online', function () {\n\n        self[self.appState.isOnline() ? 'connect' : 'close']();\n      });\n    }\n  },\n\n  /** Validates that there is an access token */\n  'validateToken': function () {\n\n    assert.string(this.appState.attributes.accessToken, 'Cannot instantiate class without an auth token.');\n  },\n\n  /** Connects to Wunderlist API WebSocket */\n  'connect': function () {\n\n    var self = this;\n\n    // close any prexising sockets\n    self.socket && self.close();\n\n    self.clientClosed = false;\n    self.clearSocketTimeout();\n\n    var config = self.appState.attributes;\n\n    var params = {\n      'client_id': config.clientID,\n      'access_token': config.accessToken,\n      'client_device_id': config.deviceID,\n      'client_instance_id': config.instanceID\n    };\n\n    var host = self.appState.attributes.realtime.host;\n    var url = URLHelper.generateURI(host, params);\n\n    var NativeWebSocketClass = self.NativeWebSocketClass;\n    self.socket = new NativeWebSocketClass(url);\n    self.bindToSocket();\n  },\n\n  /**\n    * Is the web socket really connected?\n    */\n  'isConnected': function () {\n\n    var socket = this.socket;\n    return !!(socket && socket.readyState === 1);\n  },\n\n  /**\n    * Sends a message to the Wunderlist API through connected WebSocket\n    * @param {string} message - Message to send.\n    */\n  'send': function (message) {\n\n    this.socket.send(message);\n  },\n\n  /**\n    * Close WebSocket connection if open.\n    */\n  'close': function () {\n\n    var self = this;\n    self.clientClosed = true;\n    if (self.socket) {\n      self.socket.close();\n      self.socket = undefined;\n    }\n  },\n\n  /** Binds to native WebSocket events: close, error, message, open */\n  'bindToSocket': function () {\n\n    var self = this;\n    var socket = self.socket;\n\n    socket.addEventListener('close', self.onSocketClose);\n    socket.addEventListener('error', self.onSocketError);\n    socket.addEventListener('message', self.onSocketMessage);\n    socket.addEventListener('open', self.onSocketOpen);\n\n    self.trackTimeout();\n  },\n\n  /**\n    * Timout pending socket connection after _timeout duration.\n    */\n  'trackTimeout': function () {\n\n    var self = this;\n    var timeout = self.appState.attributes.webSocketTimeout;\n\n    var start = Date.now();\n\n    var socketTimeoutLoop = function () {\n\n      if (self.socket && self.socket.readyState === 0) {\n        if (Date.now() - start < timeout) {\n          self.socketTimeout = setTimeout(socketTimeoutLoop, 1000);\n        }\n        else {\n          self.onSocketTimeout();\n          if (self.socket) {\n            self.socket.close();\n            self.socket = undefined;\n          }\n        }\n      }\n    };\n    socketTimeoutLoop();\n  },\n\n  /**\n    * Clear socketTimeout timer\n    */\n  'clearSocketTimeout': function () {\n\n    var self = this;\n    self.socketTimeout && clearTimeout(self.socketTimeout);\n  },\n\n  /**\n    * @fires module:WebSocket#timeout\n    */\n  'onSocketTimeout': function (ms) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    localConsole.error('timeout', ms);\n    /**\n      * @event module:io/io/WebSocket#timeout\n      */\n    self.trigger('timeout');\n  },\n\n  /**\n    * @fires module:WebSocket#error\n    */\n  'onSocketError': function (e) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    localConsole.error('error', e);\n    /**\n      * @event module:io/io/WebSocket#error\n      * @type {event}\n      */\n    self.trigger('error', e);\n  },\n\n  /**\n    * @fires module:WebSocket#open\n    */\n  'onSocketOpen': function (e) {\n\n    var self = this;\n\n    localConsole.info('opened', e);\n    /**\n      * @event module:io/io/WebSocket#open\n      * @type {event}\n      */\n    self.trigger('open', e);\n  },\n\n  /**\n    * @fires module:WebSocket#close\n    */\n  'onSocketClose': function (e) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    self.socket = undefined;\n    localConsole.info('closed', e);\n    /**\n      * @event module:io/io/WebSocket#close\n      * @type {event}\n      */\n    self.trigger('close', e);\n\n    /**\n      * @todo REMOVE THIS, THIS IS A HACK WHILE PLAY FRAMEWORK IS BROKEN\n      */\n    if (!self.clientClosed && self.appState.isOnline()) {\n\n      setTimeout(function () {\n\n        !self.destroyed && self.connect();\n      }, 1000);\n    }\n  },\n\n  /**\n    * @fires module:WebSocket#message\n    */\n  'onSocketMessage': function (e) {\n\n    var self = this;\n    /**\n      * @event module:io/io/WebSocket#message\n      * @type {event}\n      */\n    self.trigger('message', e);\n  }\n});\n\nmodule.exports = WebSocketClass;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/io/io/NativeWebSocket.js":"'use strict';\n\n/**\n  * Returns browser WebSocket reference, or node.js WebSocket module ws\n  * @module io/io/NativeWebSocket\n  */\n\nmodule.exports = global.WebSocket || require('ws');\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/wunderbits/lib/bindAll.js":"'use strict';\n\nvar core = require('wunderbits.core');\nvar functions = core.lib.functions;\n\n// because lodash and underscore do some stupids\nvar arrRef = [];\n\n// always use native bind regardless of \"speed\", we want less closures!\nvar bindAll = (function () {\n  return function (object) {\n    var fns = arguments.length > 1 ? arrRef.concat.apply(arrRef, arrRef.slice.call(arguments, 1)) : functions(object);\n    var key;\n\n    while (fns.length) {\n      key = fns.shift();\n      if (key !== 'constructor') {\n        object[key] = object[key].bind(object);\n      }\n    }\n  };\n})();\n\nmodule.exports = bindAll;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/index.js":"'use strict';\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nvar services = {\n  'activities': require('./Activities'),\n  'conversations': require('./Conversations'),\n  'export': require('./Export'),\n  'features': require('./Features'),\n  'files': require('./Files'),\n  'folders': require('./Folders'),\n  'import': require('./Import'),\n  'ical_feed': require('./IcalFeed'),\n  'list_positions': require('./ListPositions'),\n  'list_reminders_collections': require('./ListRemindersCollections'),\n  'lists': require('./Lists'),\n  'memberships': require('./Memberships'),\n  'notes': require('./Notes'),\n  'previews': require('./Previews'),\n  'reminders': require('./Reminders'),\n  'root': require('./Root'),\n  // Services.js in order not confuse dependency tree with folder services/index.js\n  'services': require('./Services.js'),\n  'settings': require('./Settings'),\n  'subtask_positions': require('./SubtaskPositions'),\n  'subtasks': require('./Subtasks'),\n  'task_comments': require('./TaskComments'),\n  'task_comments_states': require('./TaskCommentsStates'),\n  'task_positions': require('./TaskPositions'),\n  'tasks': require('./Tasks'),\n  'tasks_counts': require('./TasksCounts'),\n  'unread_activities_counts': require('./UnreadActivitiesCounts'),\n  'uploads': require('./Uploads'),\n  'user': require('./User'),\n  'users': require('./Users')\n};\n\nvar revisionedEndpoints = [\n  // 'file',\n  'list',\n  // 'folder',\n  // 'list_position',\n  // 'membership',\n  // 'note',\n  // 'reminder',\n  // 'service',\n  // 'setting',\n  // 'subscription',\n  // 'subtask',\n  // 'subtask_position',\n  'task'\n  // 'task_comment',\n  // 'task_position',\n  // 'upload',\n  // 'user'\n];\n\nrevisionedEndpoints.forEach(function (type) {\n\n  var revisionEndpoint = type + '_revisions';\n  services[revisionEndpoint] = ServiceGetOnly.extend({\n    'baseUrl': '/' + revisionEndpoint,\n    'type': revisionEndpoint\n  });\n});\n\nmodule.exports = services;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/ServiceGetOnly.js":"'use strict';\n\n/**\n  * @module services/ServiceGetOnly\n  * @requires module:services/Service\n  * @requires module:services/Mixin/ServiceGet\n  * @mixes module:services/Mixin/ServiceGet\n  * @extends module:services/Service\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\n\nvar BaseService = require('./Service');\nvar ServiceGet = require('./Mixins/ServiceGet');\n\nvar IOHttp = require('../io/IO');\n\nvar notAllowed = function () {\n  throw new Error ('Method not allowed for this service.');\n};\n\nmodule.exports = BaseService.extend({\n\n  'mixins': [\n    ServiceGet\n  ],\n\n  'setupRestInterfaces': function () {\n\n    var self = this;\n\n    var http = self.io = new IOHttp({\n      'config': self.appState.toJSON()\n    });\n\n    self.get = http.io.get;\n  },\n\n  /**\n    * Overrides default HTTP crud interfaces with RestSocket interfaces.\n    */\n  'setupSocketInterfaces': function () {\n\n    var self = this;\n\n    var socket = self.options.restSocket;\n\n    assert(socket, 'No RestSocket instance available.');\n\n    self.io = socket;\n    self.get = self.io.get;\n  },\n\n  'delete': notAllowed,\n  'patch': notAllowed,\n  'post': notAllowed,\n  'put': notAllowed\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Service.js":"'use strict';\n\n/**\n  * @module services/Service\n\n  * @requires module:wunderbits.core/WBEventEmitter\n\n  * @requires module:io/IO\n\n  * @requires module:services/Mixin/ServiceGet\n  * @requires module:services/Mixin/ServiceDelete\n  * @requires module:services/Mixin/ServiceCreate\n  * @requires module:services/Mixin/ServiceUpdate\n\n  * @extends module:wunderbits.core/WBEventEmitter\n\n  * @mixes module:services/Mixin/ServiceGet\n  * @mixes module:services/Mixin/ServiceDelete\n  * @mixes module:services/Mixin/ServiceCreate\n  * @mixes module:services/Mixin/ServiceUpdate\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar assert = core.lib.assert;\n\nvar ApplicationState = require('../models/ApplicationState');\nvar IOHttp = require('../io/IO');\n\nvar ServiceCreate = require('./Mixins/ServiceCreate');\nvar ServiceDelete = require('./Mixins/ServiceDelete');\nvar ServiceGet = require('./Mixins/ServiceGet');\nvar ServiceUpdate = require('./Mixins/ServiceUpdate');\n\nvar verbs = ['get', 'post', 'put', 'patch', 'delete'];\n\nvar _super = WBEventEmitter.prototype;\n\nvar BaseService = WBEventEmitter.extend({\n\n  'mixins': [\n    ServiceCreate,\n    ServiceDelete,\n    ServiceGet,\n    ServiceUpdate\n  ],\n\n  /**\n    * The service's base path. For example '/tasks' will become 'https://a.wunderlist.com/api/v1/tasks' when an HTTP request is made.\n    * @abstract\n    * @type {string}\n    */\n  'baseUrl': undefined,\n\n  /**\n    * The API version the service should use.\n    * @type {number}\n    */\n  'apiVersion': 1,\n\n  /**\n    * The service's resource type. For examples 'Task' for services/Tasks\n    * @abstract\n    * @type {string}\n    */\n  'type': undefined,\n\n  /**\n   * io helper\n   */\n  'io': undefined,\n\n  /**\n    * DELETE crud delete\n    * @method\n    */\n  'delete': undefined,\n\n  /**\n    * GET crud read\n    * @method\n    */\n  'get': undefined,\n\n  /**\n    * PATCH crud update\n    * @method\n    */\n  'patch': undefined,\n\n  /**\n    * POST crud create\n    * @method\n    */\n  'post': undefined,\n\n  /**\n    * PUT crud update\n    * @method\n    */\n  'put': undefined,\n\n  /**\n    * Base class for Wunderlist API service modules.\n    * @constructor\n    * @param {object} [options] - Class initialization options.\n    * @param {boolean} [options.websocket] - Proxy CRUD operations over a WebSocket.\n    * @alias module:services/Service\n    */\n  'initialize': function (options) {\n\n    var self = this;\n\n    _super.initialize.apply(self, arguments);\n\n    self.options = options = options || {};\n    self.appState = options.appState;\n\n    self.checkAppState();\n\n    self.baseUrl = '/v' + self.apiVersion + self.baseUrl;\n\n    if (self.options.websocket) {\n      self.setupSocketInterfaces();\n    }\n    else {\n      self.setupRestInterfaces();\n    }\n  },\n\n  'setupRestInterfaces': function () {\n\n    var self = this;\n\n    var io;\n\n    if (self.options.httpIO) {\n      io = self.options.httpIO;\n    }\n    else {\n      io = new IOHttp({\n        'config': self.appState.toJSON()\n      });\n    }\n\n    var http = self.io = io;\n\n    verbs.forEach(function (verb) {\n\n      self[verb] = http.io[verb];\n    });\n\n    self.bindTo(self.io, 'unauthorized', function () {\n\n      !self.destroyed && self.trigger('unauthorized');\n    });\n  },\n\n  /**\n    * Allows service to create its own local appstate if one is not passed\n    * in initialization options\n    */\n  'checkAppState': function () {\n\n    var self = this;\n\n    if (!self.appState && self.options.config) {\n      self.appState = new ApplicationState(self.options.config);\n      self.options.appState = self.appState;\n    }\n  },\n\n  /**\n    * Overrides default HTTP crud interfaces with RestSocket interfaces.\n    */\n  'setupSocketInterfaces': function () {\n\n    var self = this;\n    var socket = self.options.restSocket;\n\n    assert(socket, 'No RestSocket instance available.');\n\n    self.io = socket;\n\n    verbs.forEach(function (verb) {\n\n      self[verb] = self.io[verb];\n    });\n  },\n\n  /**\n    * Method to destroy and clean up instance.\n    */\n  'destroy': function () {\n\n    var self = this;\n\n    // clear all the bindings\n    self.unbindAll();\n\n    // delete all properties\n    // make sure a destroyed object is not keeping other\n    // objects alive by reference\n    function killEverything (obj) {\n      for (var key in obj) {\n        obj[key] = undefined;\n      }\n    }\n    killEverything(self);\n\n    // flag as destroyed, so objects internal methods\n    // can optionally check this before execution\n    self.destroyed = true;\n  },\n\n  /** TRUE when instance has been destroyed **/\n  'destroyed': false\n});\n\nmodule.exports = BaseService;\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Mixins/ServiceCreate.js":"'use strict';\n\n/**\n  * Provides convenience method for creating resources\n  * @module services/Mixin/ServiceCreate\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:CREATE');\n\nvar BaseServiceMixin = require('./BaseServiceMixin');\n\nmodule.exports = BaseServiceMixin.extend({\n\n  /**\n    * Creates a new resource instance view the type's baseURL\n    * @param {object} data - Data for the thing being created\n    * @param {string} [requestID] - Optional client supplied request id\n    *                               (will be auto generated otherwise)\n    * @returns {deferred} request - Request deferred object.\n    */\n  'create': function (data, requestID) {\n\n    var self = this;\n\n    var hasData = data && Object.keys(data).length;\n\n    try {\n      assert(hasData, 'Creation requires data.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    data = self.cleanCreateData(data);\n\n    try {\n      self.validateData(data, self.type);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    return self.post(self.baseUrl, data, requestID);\n  },\n\n  'cleanCreateData': function (data) {\n\n    for (var key in data) {\n      if (data[key] === null || data[key] === undefined) {\n        delete data[key];\n      }\n    }\n\n    return data;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Mixins/BaseServiceMixin.js":"'use strict';\n\n/**\n  * Base mixin for service mixins.\n  * @module services/Mixins/BaseServiceMixin\n  * @extends wunderbits/WBMixin\n  * @requires validators/SchemaValidator\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\n\nvar SchemaValidator = require('../../validators/SchemaValidator');\n\nmodule.exports = WBMixin.extend({\n  /**\n    * Passes data to be sent to the API through validators/SchemaValidator to validate data attribute types\n    * @param {object} data - hash of key value pairs to be sent as part of request\n    * @param {string} type - the type of the data e.g. 'task', 'note', etc.\n    */\n  'validateData': function (data, type) {\n    SchemaValidator.validateData(data, type);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Mixins/ServiceDelete.js":"'use strict';\n\n/**\n  * Provides convenience delete methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceDelete\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:DELETE');\n\nvar URLHelper = require('../../helpers/URL');\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Deletes an id from a resource path.\n    * @param {number} id - Id of the thing to delete.\n    * @param {number} revision - Current locally stored revision of the thing to delete.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'deleteID': function (id, revision, requestID) {\n\n    try {\n      assert.number(id, 'Deletion requires an id.');\n      assert.number(revision, 'Deletion requires a revision.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var params = {\n      'revision': revision\n    };\n\n    var paramString = URLHelper.compileParams(params);\n\n    var self = this;\n    return self['delete'](self.baseUrl + '/' + id + paramString, undefined, requestID);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Mixins/ServiceGet.js":"'use strict';\n\n/**\n  * Provides convenience methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceGet\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Performs a GET using the id as part of the URI\n    * @param {number} id - the id being fetched\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'getID': function (id, requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl + '/' + id, undefined, requestID);\n  },\n\n  /**\n    * Performs a GET using an arbitrary attribute and its id as params (?attribute=id)\n    * @param {string} url\n    * @param {string} attribute - the attribute\n    * @param {number|string} value - the attribute value\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'getItemsForAttribute': function (url, attribute, value, requestID) {\n\n    var self = this;\n    var data = {};\n\n    data[attribute] = value;\n\n    return self.get(url, data, requestID).promise();\n  },\n\n  /**\n    * Performs a GET for a user ID on the resource.\n    * @param {number} userId - The user id.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forUser': function (userId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'user_id', userId, requestID);\n  },\n\n  /**\n    * Performs a GET for a task ID on the resource.\n    * @param {number} taskId - The task ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forTask': function (taskId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'task_id', taskId, requestID);\n  },\n\n  /**\n    * Performs a GET for a list ID on the resource.\n    * @param {number} listId - The list ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forList': function (listId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'list_id', listId, requestID);\n  },\n\n  /**\n    * Perform a GET for all data for a resource without any params.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'all': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID).promise();\n  },\n\n  /**\n    * Perform a GET for all data for a resource for all lists\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forAllLists': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl + '/lists', undefined, requestID);\n  },\n\n  /**\n    * Perform a GET for all data for a resource for all tasks scoped to a list id\n    * @param {number} listId - The list ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forAllTasksForList': function (listId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl + '/tasks', 'list_id', listId, requestID);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Mixins/ServiceUpdate.js":"'use strict';\n\n/**\n  * Provides update convenience methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceUpdate\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:UPDATE');\n\nvar BaseServiceMixin = require('./BaseServiceMixin');\n\nmodule.exports = BaseServiceMixin.extend({\n\n  /**\n    * Convenience method for sending resource updates.\n    * Handles converting nulls and undefineds to a remove hash.\n    * @param {number} id - Id of the thing to update.\n    * @param {number} revision - Last known revision of the thing to update.\n    * @param {object} updateData - The updates to send to the server.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'update': function (id, revision, updateData, requestID) {\n\n    var self = this;\n    var hasData = updateData && Object.keys(updateData).length;\n\n    try {\n      assert.number(id, 'Updating a resource requires an id of type number.');\n      assert.number(revision, 'Updating a resource requires a revision of type number.');\n      assert(hasData, 'Updating a resource requires data to be sent.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0);\n    }\n\n    updateData.revision = revision;\n\n    self.validateData(updateData, self.type);\n\n    updateData = self.prepareDataForPatch(updateData);\n\n    return self.patch(self.baseUrl + '/' + id, updateData, requestID);\n  },\n\n  /**\n    * Iterates updateData for null and undefined keys and moves them to the remove array.\n    * @param {object} updateDate - The update data.\n    */\n  'prepareDataForPatch': function (updateData) {\n\n    var removals = [];\n    var value;\n\n    for (var key in updateData) {\n      value = updateData[key];\n      if (value === null || value === undefined) {\n        removals.push(key);\n        delete updateData[key];\n      }\n    }\n\n    if (removals.length) {\n      updateData.remove = removals;\n    }\n    return updateData;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Activities.js":"'use strict';\n\n/**\n  * Provides access to HTML string last 100 activities\n  * @module services/Activities\n  * @extends module:services/Conversations\n  * @requires module:services/Conversations\n\n  * @example <caption>Get HTML page with 100 latest activities</caption>\n    var ActivitiesService = require('services/Activities');\n    var activities = new ActivitiesService();\n    activities.all({\n        'style': 'desktop',\n        'tz_offset': -8\n      })\n      .done(function (data, statusCode) {\n        console.log(data.html);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar ConversationsService = require('./Conversations');\n\nmodule.exports = ConversationsService.extend({\n  'baseUrl': '/activities',\n  'type': 'activities'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Conversations.js":"'use strict';\n\n/**\n  * Provides access to HTML string last 100 conversations\n  * @module services/Conversations\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Get HTML page with 100 latest conversations</caption>\n    var Conversations = require('services/Conversations');\n    var conversations = new ConversationsService();\n    conversations.all({\n        'style': 'desktop',\n        'tz_offset': -8\n      })\n      .done(function (data, statusCode) {\n        console.log(data.html);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/conversations',\n  'type': 'conversations',\n\n  'all': function (params, requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, params, requestID).promise();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/AuthenticatedService.js":"'use strict';\n\n/**\n  * @module services/AuthenticatedService\n  * @extends module:services/Service\n  * @requires module:services/Service\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\n\nvar BaseService = require('./Service');\n\nvar _super = BaseService.prototype;\n\nmodule.exports = BaseService.extend({\n\n  /**\n    * Base class for Wunderlist API service modules that require authentication.\n    * @constructor\n    * @alias module:services/AuthenticatedService\n    */\n  'initialize': function () {\n    var self = this;\n    _super.initialize.apply(self, arguments);\n    self.validateAccessParams();\n  },\n\n  /**\n    * Checks that clientID and accessToken are available\n    */\n  'validateAccessParams': function () {\n\n    var self = this;\n    var config = self.appState.attributes;\n    assert.string(config.clientID, 'This service requires a client ID.');\n    assert.string(config.accessToken, 'This service requires an access token.');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Export.js":"'use strict';\n\n/**\n  * Provides access to the export service\n  * @module services/Export\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/export',\n  'type': 'export',\n\n  'all': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID, 300000).promise();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Features.js":"'use strict';\n\n/**\n  * Provides access to user's features\n  * @module services/Features\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/features',\n\n  'type': 'feature'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Files.js":"'use strict';\n\n/**\n  * Provides methods for easy access to files data.\n  * @module services/Files\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Files service</caption>\n    var FilesService = require('services/Files');\n    var files = new FilesService();\n\n  * @example <caption>Get files for a task</caption>\n    var taskID = 78987;\n    files.forTask(taskID)\n      .done(function (filesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get files for a list</caption>\n    var listID = 87987;\n    files.forList(listID)\n      .done(function (filesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific file</caption>\n    var fileID = 34958737;\n    files.getID(fileID)\n      .done(function (fileData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a file</caption>\n    var fileData = {\n      'upload_id': 458748574,\n      'task_id': 4958,\n      'file_name': 'awesome file.zip'\n    };\n    notes.create(noteData)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a file</caption>\n    var fileID = 3487348374;\n    var revision = 45;\n    notes.deleteID(fileID, revision)\n      .always(function (resp, statusCode) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:FILES');\n\nvar AuthenticatedService = require('./AuthenticatedService');\nvar _super = AuthenticatedService.prototype;\n\nmodule.exports = AuthenticatedService.extend({\n\n  'apiVersion': 2,\n  'baseUrl': '/files',\n  'type': 'file',\n\n  'create': function (data, requestID) {\n\n    var self = this;\n\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.call(self, data, requestID);\n    return request.promise();\n  },\n\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for file creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.task_id, 'data.task_id' + required);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Folders.js":"'use strict';\n\n/**\n * Provides methods for easy access to folder data.\n * @module services/Folder\n * @extends module:services/AuthenticatedService\n * @requires module:services/AuthenticatedService\n\n * @example <caption>Create an instance of the Folders service</caption>\n var FolderService = require('services/Folders');\n var folders = new FolderService();\n\n * @example <caption>Get all folders for a user_id</caption>\n var userID = 984587;\n folders.forUser(userID)\n .done(function (folderData, statusCode) {\n        // ...\n      })\n .fail(function (resp, code) {\n        // ...\n      });\n\n * @example <caption>Get a specific folder</caption>\n vat folderID = 777;\n folders.getID(folderID)\n .done(function (folderData, statusCode) {\n        // ...\n      })\n .fail(function (resp, code) {\n        // ...\n      });\n\n * @example <caption>Create a folder</caption>\n folders.create({\n      'title': 'Bad Movies'\n    })\n .done(function (folderData, statusCode) {\n      // ...\n    })\n .fail(function (resp, code) {\n      // ...\n    });\n\n * @example <caption>Update a folder</caption>\n var folderID = 777;\n var folderRevision = 5;\n var updateData = {\n      'title': 'Good Bad Movies',\n    };\n\n folders.update(folderID, folderRevision, updateData)\n .done(function (folderData, statusCode) {\n        // ...\n      })\n .fail(function (resp, code) {\n        // ...\n      });\n\n * @example <caption>Delete a folder</caption>\n var folderID = 777;\n var folderRevision = 5;\n folders.deleteID(folderID, folderRevision)\n .always(function (resp, code) {\n        // ...\n      });\n */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:FOLDERS');\n\nvar MembershipsService = require('./Memberships');\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n    'baseUrl': '/folders',\n\n    'type': 'folder',\n\n\n    'initialize': function (options) {\n\n        var self = this;\n        _super.initialize.apply(self, arguments);\n\n        self.membershipsService = new MembershipsService(options);\n    },\n\n    /**\n     * Create a folder.\n     * @param {object} data - Folder creation data.\n     * @param {string} data.title - Folder title.\n     * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n     * @returns {promise} Promise of request deferred.\n     */\n    'create': function (data) {\n\n        var self = this;\n        try {\n            self.validateCreateData(data);\n        }\n        catch (e) {\n            localConsole.error(e);\n            return new WBDeferred().reject({\n                'errors': [e.toString()]\n            }, 0).promise();\n        }\n\n        var request = _super.create.apply(self, arguments);\n        return request.promise();\n    },\n\n    /**\n     * Returns current user's accepted folders only\n     */\n    'accepted': function () {\n\n        var self = this;\n        var deferred = new WBDeferred();\n\n        self.membershipsService.mine()\n            .done(function (myMemberships) {\n\n                var acceptedMemberships = myMemberships.filter(function (membership) {\n\n                    return membership.state === 'accepted';\n                });\n\n                var acceptedIDs = acceptedMemberships.map(function (acceptedMembership) {\n\n                    return acceptedMembership.folder_id;\n                });\n\n                self.all()\n                    .done(function (allFolders) {\n\n                        var myFolders = allFolders.filter(function (folder) {\n\n                            return acceptedIDs.indexOf(folder.id) > -1;\n                        });\n\n                        deferred.resolve(myFolders);\n                    })\n                    .fail(deferred.reject, deferred);\n            })\n            .fail(deferred.reject, deferred);\n\n        return deferred.promise();\n    },\n\n    /**\n     * Validates subtask creation data.\n     * @param {object} data - Subtask data.\n     */\n    'validateCreateData': function (data) {\n\n        data = data || {};\n        assert(data.title, 'Title is required for folder creation.');\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Memberships.js":"'use strict';\n\n/**\n  * Provides methods for easy access to memberships data.\n  * @module services/Memberships\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Memberships service</caption>\n    var MembershipsService = require('services/Memberships');\n    var memberships = new MembershipsService();\n\n  * @example <caption>Get all memberships for a user</caption>\n    var userID = 5687;\n    memberships.forUser(userID)\n      .done(function (memberhipsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all memberships for a list</caption>\n    var listID = 56879;\n    memberships.forList(listID)\n      .done(function (memberhipsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Invite a user to a list</caption>\n    var membershipData = {\n      'list_id': 5687,\n      'user_id': 4340598\n    };\n    memberships.create(membershipData)\n      .done(function (newMembership, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Invite an email address to a list</caption>\n    var membershipData = {\n      'email': 'TheDarkKnight@arkham.asylum',\n      'user_id': 4340598\n    };\n    memberships.create(membershipData)\n      .done(function (newMembership, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Accept a pending membership</caption>\n    var membershipID = 569859;\n    var membershipRevision = 0;\n    var acceptData = {\n      'state': 'accepted'\n    };\n    memberships.update(membershipID, membershipRevision, acceptData)\n      .done(function (membershipData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a membership</caption>\n    var membershipID = 569859;\n    var membershipRevision = 0;\n    memberships.delete(membershipID, membershipRevision)\n      .done(function (data, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar UserService = require('./User');\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/memberships',\n  'type': 'membership',\n\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.userService = new UserService(options);\n  },\n\n  'mine': function () {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    self.userService.all()\n      .done(function (userData) {\n\n        self.forUser(userData.id)\n          .done(deferred.resolve, deferred)\n          .fail(deferred.reject, deferred);\n      })\n      .fail(deferred.reject, deferred);\n\n    return deferred.promise();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/User.js":"'use strict';\n\n/**\n  * Provides methods for easy access to user data for\n  * the currently signed in user.\n  * @module services/User\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the User service</caption>\n    var UserService = require('services/User');\n    var user = new UserService();\n\n  * @example <caption>Fetch all info for the currently logged in user</caption>\n    user.all()\n      .done(function (userData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:USER');\n\nvar AuthenticatedService = require('./AuthenticatedService');\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/user',\n  'type': 'user',\n\n  'update': function (revision, updateData, requestID) {\n\n    var self = this;\n    var hasData = updateData && Object.keys(updateData).length;\n\n    try {\n      assert.number(revision, 'Updating a user requires a revision of type number.');\n      assert(hasData, 'Updating a user requires data to be sent.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    updateData.revision = revision;\n\n    try {\n      self.validateData(updateData, self.type);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0);\n    }\n\n    updateData = self.prepareDataForPatch(updateData);\n\n    return self.patch(self.baseUrl, updateData, requestID);\n  },\n\n  'changeEmail': function (newEmail, password, requestID) {\n\n    var self = this;\n\n    var data = {\n      'email': newEmail,\n      'password': password\n    };\n\n    return self.patch(self.baseUrl + '/email', data, requestID);\n  },\n\n  'changePassword': function (newPassword, currentPassword, requestID) {\n\n    var self = this;\n\n    var updateData = {\n      'password': newPassword,\n      'old_password': currentPassword\n    };\n\n    return self.patch(self.baseUrl + '/password', updateData, requestID);\n  },\n\n  'deleteSelf': function (password, requestID) {\n\n    var self = this;\n\n    var params = {\n      'password': password\n    };\n\n    return self['delete'](self.baseUrl, params, requestID);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Import.js":"'use strict';\n\n/**\n  * Provides methods for easy access to the import endpoint.\n  * @module services/Import\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/import',\n  'type': 'import',\n\n  'create': function (data, requestID) {\n\n    var self = this;\n    return self.post(self.baseUrl, data, requestID, 300000).promise();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/IcalFeed.js":"'use strict';\n\n/**\n  * Provides access for fetching the user's ical feed url\n  * @module services/Products\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/ical/feed',\n  'type': 'ical_feed',\n\n  'getURL': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID).promise();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/ListPositions.js":"'use strict';\n\n/**\n  * Provides methods for easy access to list positions.\n  * @module services/ListPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the ListPositions service</caption>\n    var ListPositionsService = require('services/ListPositions');\n    var listPositions = new ListPositionsService();\n\n\n  * @example <caption>Get all list positions</caption>\n    var ListPositions = require('services/ListPositions');\n    var listPositions = new ListPositions();\n    listPositions.all()\n      .done(function (listPositions, statusCode) {\n        //...\n      })\n      .fail(function (resp, code) {\n        //...\n      });\n\n  * @example <caption>Update a lists positions object</caption>\n    var listPositionsID = 678;\n    var listPositionsRevision = 6;\n    var updateData = {\n      'values': [123,345,567]\n    };\n    listPositions.update(listPositionsID, listPositionsRevision, updateData)\n      .done(function (listPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/list_positions',\n  'type': 'list_position'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/ListRemindersCollections.js":"'use strict';\n\n/**\n  * Provides methods for easy access to users data.\n  * @module services/Users\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Users service</caption>\n    var UsersService = require('services/Users');\n    var users = new UsersService();\n\n  * @example <caption>Fetch the users this logged in user can access</caption>\n    users.all()\n      .done(function (usersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/list_reminders_collections',\n  'type': 'list_reminders_collection'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Lists.js":"'use strict';\n\n/**\n  * Provides methods for easy access to list data.\n  * @module services/Lists\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Lists service</caption>\n    var ListsService = require('services/Lists');\n    var lists = new ListsService();\n\n  * @example <caption>Get all lists for a user_id</caption>\n    var userID = 984587;\n    lists.forUser(listID)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific list</caption>\n    vat listID = 777;\n    lists.getID(listID)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a list</caption>\n    lists.create({\n      'title': 'Bad Movies'\n    })\n    .done(function (listData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a list</caption>\n    var listID = 777;\n    var listRevision = 5;\n    var updateData = {\n      'title': 'Good Bad Movies',\n    };\n\n    lists.update(listID, listRevision, updateData)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a list</caption>\n    var listID = 777;\n    var listRevision = 5;\n    lists.deleteID(listID, listRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:LISTS');\n\nvar MembershipsService = require('./Memberships');\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/lists',\n\n  'type': 'list',\n\n\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.membershipsService = new MembershipsService(options);\n  },\n\n  /**\n    * Create a list.\n    * @param {object} data - List creation data.\n    * @param {string} data.title - List title.\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Returns current user's accepted lists only\n    */\n  'accepted': function () {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    self.membershipsService.mine()\n      .done(function (myMemberships) {\n\n        var acceptedMemberships = myMemberships.filter(function (membership) {\n\n          return membership.state === 'accepted';\n        });\n\n        var acceptedIDs = acceptedMemberships.map(function (acceptedMembership) {\n\n          return acceptedMembership.list_id;\n        });\n\n        self.all()\n          .done(function (allLists) {\n\n            var myLists = allLists.filter(function (list) {\n\n              return acceptedIDs.indexOf(list.id) > -1;\n            });\n\n            deferred.resolve(myLists);\n          })\n          .fail(deferred.reject, deferred);\n      })\n      .fail(deferred.reject, deferred);\n\n    return deferred.promise();\n  },\n\n  /**\n    * Validates subtask creation data.\n    * @param {object} data - Subtask data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n    assert(data.title, 'Title is required for list creation.');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Notes.js":"'use strict';\n\n/**\n  * Provides methods for easy access to note data.\n  * @module services/Notes\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Notes service</caption>\n    var NotesService = require('services/Notes');\n    var notes = new NotesService();\n\n  * @example <caption>Get notes for a task</caption>\n    var taskID = 78987;\n    notes.forTask(taskID)\n      .done(function (notesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get notes for a list</caption>\n    var listID = 87987;\n    notes.forList(listID)\n      .done(function (notesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific note</caption>\n    var noteID = 34958737;\n    notes.getID(noteID)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a note</caption>\n    var noteData = {\n      'task_id': 458748574,\n      'content': '2 + 2 = 5'\n    };\n    notes.create(noteData)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a note</caption>\n    var noteID = 3487348374;\n    var revision = 45;\n    notes.deleteID(noteID, revision)\n      .always(function (resp, statusCode) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/notes',\n  'type': 'note',\n\n  /**\n    * Allows fetching notes for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch notes under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Previews.js":"'use strict';\n\n/**\n  * Provides methods for easy access to file preview data.\n  * @module services/Previews\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Previews service</caption>\n    var PreviewsService = require('services/Previews');\n    var previews = new PreviewsService();\n\n  * @example <caption>Get preview for a file</caption>\n    var fileID = 87987;\n    previews.getPreview(fileID)\n      .done(function (previewData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/previews',\n  'type': 'preview',\n\n  // GET a.wunderlist.com/api/v1/files/:id/preview?platform=mac&size=retina\n  'getPreview': function (id, platform, size, requestID) {\n\n    var self = this;\n\n    var params = {\n      'file_id': id,\n      'platform': platform,\n      'size': size\n    };\n\n    return self.get(self.baseUrl, params, requestID);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Reminders.js":"'use strict';\n\n/**\n  * Provides methods for easy access to reminder data.\n  * @module services/Reminders\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Reminders service</caption>\n    var RemindersService = require('services/Reminders');\n    var reminders = new RemindersService();\n\n  * @example <caption>Get reminders for a task</caption>\n    var taskID = 349587;\n    reminders.forTask(taskID)\n      .done(function (remindersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get reminders for a list</caption>\n    var listID = 349587;\n    reminders.forList(listID)\n      .done(function (remindersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific reminder</caption>\n    var reminderID = 34958734958;\n    reminder.getID(reminderID)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a reminder</caption>\n    var reminderData = {\n      'task_id': 59191,\n      'date': '2013-08-30T08:29:46.203Z'\n    };\n    reminders.create(reminderData)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update a reminder</caption>\n    var reminderID = 349587;\n    var reminderRevision = 23;\n    var reminderUpdateData = {\n      'date': '2275-08-30T08:29:46.203Z'\n    };\n    reminders.update(reminderID, reminderRevision, reminderUpdateData)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a reminder</caption>\n    var reminderID = 2395872394;\n    reminders.deleteID(reminderID)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/reminders',\n  'type': 'reminder',\n\n  /**\n    * Allows fetching reminders for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch reminders under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Root.js":"'use strict';\n\n/**\n  * Provides methods for easy access to root.\n  * @module services/Root\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Root service</caption>\n    var RootService = require('services/Root');\n    var root = new RootService();\n\n  * @example <caption>Get a user's root object</caption>\n    root.all()\n      .done(function (rootData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/root',\n  'type': 'root'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Services.js":"'use strict';\n\n/**\n  * Provides access to oauth services\n  * @module services/Services\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/services',\n  'type': 'service'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Settings.js":"'use strict';\n\n/**\n  * Provides methods for easy access to user settings.\n  * @module services/Settings\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Settings service</caption>\n    var SetttingsService = require('services/Settings');\n    var settings = new SetttingsService();\n\n  * @example <caption>Get all of a user's settings</caption>\n    settings.all()\n      .done(function (settingsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific setting</caption>\n    var settingID = 5458787;\n    settings.getID(settingID)\n      .done(function (settingData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a setting</caption>\n    var settingData = {\n      'key': 'difficulty',\n      'value': 'hard mode'\n    };\n    settings.create(settingData)\n      .done(function (settingData, statusCode) {\n\n      })\n      .fail(function (resp, code) {\n\n      });\n\n  * @example <caption>Update a setting</caption>\n    var settingID = 349587;\n    var settingRevision = 87;\n    var settingUpdateData = {\n      'value': 'insanity'\n    };\n\n    settings.update(settingID, settingRevision, settingUpdateData)\n      .done(function (settingData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a setting</caption>\n    var settingID = 349587;\n    var settingRevision = 88;\n    settings.deleteID(settingID, settingRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/settings',\n  'type': 'setting'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/SubtaskPositions.js":"'use strict';\n\n/**\n  * Provides methods for easy access to task positions.\n  * @module services/SubtaskPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the SubtaskPositions service</caption>\n    var SubtaskPositionsService = require('services/SubtaskPositions');\n    var subtaskPositions = new SubtaskPositionsService();\n\n  * @example <caption>Get positions for a task's subtasks</caption>\n    var taskID = 123987;\n    subtaskPositions.forTask(taskID)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get subtasks positions for all tasks in a list</caption>\n    var listID = 123987;\n    subtaskPositions.forList(listID)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific subtask position object</caption>\n    var subtaskPositionID = 239487;\n    subtaskPositions.getID(subtaskPositionID)\n      .done(function (subtaskPositionData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update positions for a task's subtasks</caption>\n    var subtaskPositionsID = 349587;\n    var subtaskPositionsRevision = 23;\n    var updateData = {\n      'values': [2234,45645,76567,567978]\n    };\n    subtaskPositions.update(subtaskPositionsID, subtaskPositionsRevision, updateData)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/subtask_positions',\n  'type': 'subtask_position',\n\n  /**\n    * Allows fetching subtask_positions for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch subtask_positions under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Subtasks.js":"'use strict';\n\n/**\n  * Provides methods for easy access to subtasks data.\n  * @module services/Subtasks\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n* @example <caption>Create an instance of the Subtasks service</caption>\n    var SubtasksService = require('services/Subtasks');\n    var subtasks = new SubtasksService();\n\n  * @example <caption>Get all uncompleted subtasks for a list</caption>\n    var listID = 666;\n    subtasks.forList(listID)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed subtasks for a list</caption>\n    var listID = 3456\n    var completed = true;\n    subtasks.forList(listID, completed)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all uncompleted subtasks for a task</caption>\n    var taskID = 666;\n    subtasks.forTask(taskID)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed subtasks for a task</caption>\n    var taskID = 3456\n    var completed = true;\n    subtasks.forTask(taskID, completed)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific subtask</caption>\n    vat subtaskID = 777;\n    subtasks.getID(subtaskID)\n      .done(function (subtaskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a subtask</caption>\n    subtasks.create({\n      'task_id': 8675309\n      'title': 'Call Jenny'\n    })\n    .done(function (subtaskData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a subtask</caption>\n    var subtaskID = 777;\n    var subtaskRevision = 5;\n    var updateData = {\n      'title': 'Change the world'\n    };\n    subtasks.update(subtaskID, subtaskRevision, updateData)\n      .done(function (subtaskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a subtask</caption>\n    var subtaskID = 777;\n    var subtaskRevision = 5;\n    subtasks.deleteID(subtaskID, subtaskRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:SUBTASKS');\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/subtasks',\n\n  'type': 'subtask',\n\n   /**\n    * Create a subtask.\n    * @param {object} data - Subtask creation data.\n    * @param {integer} data.task_id - Task ID which subtask belongs to.\n    * @param {string} data.title - Subtask title. Maximum length is 255 characters.\n    * @param {boolean} [data.completed] - Is subtask completed?\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Allows fetching either all or just uncompleted subtasks for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch for completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n\n  /**\n    * Validates subtask creation data.\n    * @param {object} data - Subtask data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for subtask creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.task_id, 'data.task_id' + required);\n    assert.string(data.title, 'data.title' + required);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/TaskComments.js":"'use strict';\n\n/**\n  * Provides methods for easy access to task comments.\n  * @module services/TaskComments\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskComments service</caption>\n    var TaskCommentsService = require('services/TaskComments');\n    var taskComments = new TaskCommentsService();\n\n  * @example <caption>Get all comments for a task</caption>\n    var taskID = 239487;\n    taskComments.forTask(taskID)\n      .done(function (taskCommentsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all task comments for all tasks in a list</caption>\n    var listID = 239487;\n    taskComments.forList(listID)\n      .done(function (taskCommentsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a task comment</caption>\n    taskComments.create({\n      'task_id': 349587,\n      'text': 'Hello world!'\n    })\n    .done(function (taskCommentData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Mark a task comment as having been read</caption>\n    var taskCommentID = 2394872;\n    var taskCommentRevision = 1;\n    var readData = {\n      'read': true\n    };\n    taskComments.update(taskCommentID, taskCommentRevision, readData)\n      .done(function (taskCommentData, statusCode) {\n        // ...\n      })\n      .fail(fucntion (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_comments',\n  'type': 'task_comment'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/TaskCommentsStates.js":"'use strict';\n\n/**\n  * Provides methods for easy access to task comments states\n  * @module services/TaskCommentsStates\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskCommentsStates service</caption>\n    var TaskCommentsStatesService = require('services/TaskCommentsStates');\n    var taskCommentsStates = new TaskCommentsStatesService();\n\n  * @example <caption>Get the comments states for a list</caption>\n    var listID = 239487;\n    taskCommentsStates.forList(listID)\n      .done(function (taskCommentsStatesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_comments_states',\n  'type': 'task_comments_state'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/TaskPositions.js":"'use strict';\n\n/**\n  * Provides methods for easy access to task positions.\n  * @module services/TaskPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskPositions service</caption>\n    var TaskPositionsService = require('services/TaskPositions');\n    var taskPositions = new TaskPositionsService();\n\n  * @example <caption>Get task positions for a list</caption>\n    var listID = 123987;\n    taskPositions.forList(listID)\n      .done(function (taskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific task position object</caption>\n    var taskPositionID = 239487;\n    taskPositions.getID(taskPositionID)\n      .done(function (taskPositionData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update positions for a list's tasks</caption>\n    var taskPositionsID = 349587;\n    var taskPositionsRevision = 23;\n    var updateData = {\n      'values': [2234,45645,76567,567978]\n    };\n    taskPositions.update(taskPositionsID, taskPositionsRevision, updateData)\n      .done(function (taskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_positions',\n  'type': 'task_position'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Tasks.js":"'use strict';\n\n/**\n  * Provides methods for easy access to tasks data.\n  * @module services/Tasks\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Tasks service</caption>\n    var TasksService = require('services/Tasks');\n    var tasks = new TasksService();\n\n  * @example <caption>Get all uncompleted tasks for a list</caption>\n    var listID = 666;\n    tasks.forList(listID)\n      .done(function (tasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed tasks for a list</caption>\n    var listID = 3456;\n    var completed = true;\n    tasks.forList(listID, completed)\n      .done(function (tasks, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific task</caption>\n    vat taskID = 777;\n    tasks.getID(taskID)\n      .done(function (taskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a task</caption>\n    tasks.create({\n      'list_id': 8675309\n      'title': 'Call Jenny'\n    })\n    .done(function (taskData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a task</caption>\n    var taskID = 777;\n    var taskRevision = 5;\n    var updateData = {\n      'title': 'Change the world',\n      'starred': true,\n      'due_data': undefined\n    };\n\n    tasks.update(taskID, revision, updateData)\n      .done(function (taskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a task</caption>\n    var taskID = 777;\n    var taskRevision = 5;\n    tasks.deleteID(taskID, taskRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:TASKS');\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/tasks',\n\n  'type': 'task',\n\n  /**\n    * Allows fetching either all or just uncompleted tasks for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} completed - Fetch completed tasks or not.\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n\n      'list_id': listId,\n      'completed': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n\n  /**\n    * Create a task.\n    * @param {object} data - Task data.\n    * @param {integer} data.list_id - List ID in which to create task.\n    * @param {string} data.title - Task title.\n    * @param {integer} [data.assignee_id] - User task is assigned to.\n    * @param {boolean} [data.completed] - Is task completed?\n    * @param {string} [data.due_date] - Task due date formatted as an ISO8601 date.\n    * @param {boolean} [data.starred] - Is task starred?\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Validates task creation data.\n    * @param {object} data - Task data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for task creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.list_id, 'data.list_id' + required);\n    assert.string(data.title, 'data.title' + required);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/TasksCounts.js":"'use strict';\n\n/**\n  * Provides methods for easy access to tasks_count data.\n  * @module services/TasksCount\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TasksCount service</caption>\n    var TasksCountService = require('services/TasksCount');\n    var taskCounts = new TasksCountService();\n\n  * @example <caption>Get a list's task counts</caption>\n    var listID = 4349587;\n    taskCounts.forList(listID)\n      .done(function (taskCounts, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/lists/tasks_count',\n  'type': 'tasks_count'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/UnreadActivitiesCounts.js":"'use strict';\n\n/**\n  * Provides access to unread counts for Activities and Comments\n  * @module services/UnreadCounts\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Get unread counts for Activities and Comments</caption>\n    var UnreadCountsService = require('services/UnreadCounts');\n    var unreadCounts = new UnreadCountsService();\n    unreadCounts.all()\n      .done(function (data, statusCode) {\n        console.log(data.comments);\n        console.log(data.activities);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/unread_activity_counts',\n  'type': 'unread_activities_count'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Uploads.js":"'use strict';\n\n/**\n  * Provides methods for easy access to uploads data.\n  * @module services/Uploads\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Uploads service</caption>\n    var UploadsService = require('services/Uploads');\n    var uploads = new FilesService();\n\n  * @example <caption>Create a upload</caption>\n\n    uploads.create()\n      .done(function (uploadData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update a upload</caption>\n    var uploadID = 777;\n    var uploadRevision = 2398;\n    var updateData = {\n      'state': 'finished'\n    };\n    uploads.update(uploadID, uploadRevision, updateData)\n      .done(function (uploadData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/uploads',\n  'type': 'upload',\n\n  // upload creation does not require data, but preserving\n  'create': function (data, requestID) {\n\n    var self = this;\n    return self.post(self.baseUrl, data, requestID);\n  },\n\n  'getPart': function (id, partNumber, requestID) {\n\n    var self = this;\n\n    var params = {\n      'part_number': partNumber\n    };\n\n    return self.get(self.baseUrl + '/' + id + '/parts', params, requestID);\n  },\n\n  'finish': function (id, requestID) {\n\n    var self = this;\n\n    var params = {\n      'state': 'finished'\n    };\n\n    return self.patch(self.baseUrl + '/' + id, params, requestID);\n  }\n});","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/services/Users.js":"'use strict';\n\n/**\n  * Provides methods for easy access to users data.\n  * @module services/Users\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Users service</caption>\n    var UsersService = require('services/Users');\n    var users = new UsersService();\n\n  * @example <caption>Fetch the users this logged in user can access</caption>\n    users.all()\n      .done(function (usersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/users',\n  'type': 'user'\n});\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/urls.js":"'use strict';\n\nmodule.exports = {};\n","/home/travis/build/npmtest/node-npmtest-wunderlist/node_modules/wunderlist/public/helpers/Logger.js":"'use strict';\n\n/**\n  * Logger that only logs or warns if SDK configured for debug mode.\n  * @module helpers/Logger\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar Console = global.console;\n\nvar Logger = WBSingleton.extend({\n\n  'debug': false,\n\n  'enable': function () {\n\n    this.debug = true;\n  },\n\n  'disable': function () {\n\n    this.debug = false;\n  },\n\n  /** Logs to the console */\n  'log': function () {\n\n    this.shouldRun() && Console.log.apply(Console, arguments);\n  },\n\n  /** Warns to the console */\n  'warn': function () {\n\n    this.shouldRun() && Console.warn.apply(Console, arguments);\n  },\n\n  /** Checks if SDK in debug mode */\n  'shouldRun': function () {\n\n    return !!(this.debug && Console);\n  }\n});\n\nmodule.exports = Logger;\n"}